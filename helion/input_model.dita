<?xml version="1.0" encoding="UTF-8"?>
<!--This work by HPE Helion Openstack is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License. See the accompanying LICENSE file for more information.-->
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="input_model">
  <title><ph conkeyref="HOS-conrefs/product-title"/>Input Model</title>
  <conbody>
    <p conkeyref="HOS-conrefs/applies-to"/>
    <section id="toc"><title>Table of Contents</title>
      <ul>
        <li><xref keyref="input_model_introduction">Introduction</xref></li>
        <li><xref keyref="concepts"><keyword keyref="kw-hos-phrase"/> Concepts</xref>
          <ul>
            <li><xref keyref="concept_cloud">Cloud</xref></li>
            <li><xref keyref="concept_controlplanes">Control Planes</xref>
              <ul>
                <li><xref href="#input_model/controlplanes_regions">Control Planes and
                    Regions</xref></li>
              </ul></li>
            <li><xref href="#input_model/services">Services</xref></li>
            <li><xref href="#input_model/serverroles">Server Roles</xref></li>
            <li><xref href="#input_model/diskmodel">Disk Model</xref></li>
            <li><xref href="#input_model/servers">Servers</xref></li>
            <li><xref href="#input_model/servergroups">Server Groups</xref>
              <ul>
                <li><xref href="#input_model/servergroups_failurezones">Server Groups and Failure
                    Zones</xref></li>
                <li><xref href="#input_model/servergroups_networks">Server Groups and
                    Networks</xref></li>
              </ul></li>
            <li><xref href="#input_model/networking">Networking</xref>
              <ul>
                <li><xref href="#input_model/networkgroups">Network Groups</xref>
                  <ul>
                    <li><xref href="#input_model/loadbalancers">Load Balancers</xref></li>
                    <li><xref href="#input_model/networktags">Network Tags</xref></li>
                  </ul></li>
                <li><xref href="#input_model/networks">Networks</xref></li>
                <li><xref href="#input_model/interfacemodel">Interface Model</xref></li>
                <li><xref href="#input_model/nicmapping">NIC Mapping</xref></li>
                <li><xref href="#input_model/firewallconfiguration">Firewall
                  Configuration</xref></li>
              </ul></li>
          </ul></li>
        <li><xref keyref="configurationobjects"><keyword keyref="kw-hos-phrase"/> Configuration
            Objects</xref>
          <ul>
            <li><xref keyref="configobj_cloud">Cloud</xref></li>
            <li><xref keyref="configobj_controlplane">Control Plane</xref>
              <ul>
                <li><xref keyref="configobj_clusters">Clusters</xref></li>
                <li><xref keyref="configobj_resources">Resources</xref></li>
              </ul></li>
            <li><xref keyref="configobj_servers">Servers</xref></li>
            <li><xref keyref="configobj_servergroups">Server Groups</xref></li>
            <li><xref keyref="configobj_serverroles">Server Roles</xref></li>
            <li><xref keyref="configobj_diskmodels">Disk Models</xref>
              <ul>
                <li><xref keyref="configobj_volumegroups">Volume Groups</xref></li>
                <li><xref keyref="configobj_devicegroups">Device Groups</xref></li>
              </ul></li>
            <li><xref keyref="configobj_interfacemodels">Interface Models</xref>
              <ul>
                <li><xref keyref="configobj_bonddata">Bond Data</xref></li>
              </ul></li>
            <li><xref keyref="configobj_nicmappings">NIC Mappings</xref></li>
            <li><xref keyref="configobj_networkgroups">Network Groups</xref>
              <ul>
                <li><xref keyref="configobj_networktags">Network Tags</xref></li>
              </ul></li>
            <li><xref keyref="configobj_networks">Networks</xref></li>
            <li><xref keyref="configobj_firewallrules">Firewall Rules</xref>
              <ul>
                <li><xref keyref="configobj_rule">Rule</xref></li>
              </ul></li>
            <li><xref keyref="passthrough">Passthrough</xref></li>
          </ul></li>
        <li><xref keyref="othertopics">Other Topics</xref>
          <ul>
            <li><xref keyref="namegeneration">Name Generation</xref>
              <ul>
                <li><xref keyref="namegeneration/o_clusters"> Clusters</xref></li>
                <li><xref keyref="namegeneration/o_resourcenodes">Resource Nodes</xref></li>
              </ul></li>
            <li><xref keyref="persisteddata">Persisted Data</xref>
              <ul>
                <li><xref keyref="persisteddata/persistedserverallocations">Persisted Server
                    Allocations</xref></li>
                <li><xref keyref="persisteddata/persistedaddressallocations">Persisted Address
                    Allocations</xref></li>
              </ul></li>
            <li><xref keyref="serverallocation">Server Allocation</xref></li>
            <li><xref keyref="servernetworkselection">Server Network
              Selection</xref></li>
            <li><xref keyref="networkroutevalidation">Network Route
              Validation</xref></li>
            <li><xref keyref="configneutronprovidervlans">Configuring Neutron Provider
                VLANs</xref></li>
          </ul></li>
        <li><xref keyref="cpinfofiles">Configuration Processor Information Files</xref>
          <ul>
            <li><xref keyref="address_info_yml">Address_info.yml</xref></li>
            <li><xref keyref="firewall_info_yml">Firewall_info.yml</xref></li>
            <li><xref keyref="net_info_yml">Net_info.yml</xref></li>
            <li><xref keyref="route_info_yml">Route_info.yml</xref></li>
            <li><xref keyref="server_info_yml">Server_info.yml</xref></li>
            <li><xref keyref="service_info_yml">Service_info.yml</xref></li>
            <li><xref keyref="explain_txt">explain.txt</xref></li>
            <li><xref keyref="clouddiagram_txt">CloudDiagram.txt</xref></li>
          </ul></li>
      </ul>
    </section>
    


    
    
    
    
    
    
    
    <section id="diskmodel"><title>Disk Model</title>
      <p><i>Each physical disk device is associated with a <uicontrol>device-group</uicontrol> or a
            <uicontrol>volume-group</uicontrol>.</i></p>
      <p><i><uicontrol>Device-groups</uicontrol> are consumed by
          <uicontrol>services</uicontrol>.</i></p>
      <p><i><uicontrol>Volume-groups</uicontrol> are divided into
            <uicontrol>logical-volumes</uicontrol>.</i></p>
      <p><i><uicontrol>Logical-volumes</uicontrol> are mounted as file systems or consumed by
          services.</i></p>
      <p>Disk-models define how local storage is to be configured and presented to
          <uicontrol>services</uicontrol>. Disk-models are identified by a name, which you will
        specify. The <keyword keyref="kw-hos"/> examples provide some typical configurations. As this is
        an area that varies with respect to the services that are hosted on a server and the number
        of disks available, it is impossible to cover all possible permutations you may need to
        express via modifications to the examples.</p>
      <p>Within a <uicontrol>disk-model</uicontrol>, disk devices are assigned to either a
          <uicontrol>device-group</uicontrol> or a <uicontrol>volume-group</uicontrol>.</p>
      <p><image href="../media/inputmodel/hphelionopenstack_diskmodels.png"/></p>
      <p><xref href="../media/inputmodel/hphelionopenstack_diskmodels_lg.png" scope="external"
          format="html">Download a high-res version</xref></p>
      <p>A <uicontrol>device-group</uicontrol> is a set of one or more disks that are to be consumed
        directly by a service. For example, a set of disks to be used by Swift. The device-group
        identifies the list of disk devices, the service, and a few service-specific attributes that
        tell the service about the intended use (for example, in the case of Swift this is the ring
        names). When a device is assigned to a device-group, the associated service is responsible
        for the management of the disks. This management includes the creation and mounting of file
        systems. (Swift can provide additional data integrity when it has full control over the file
        systems and mount points.)</p>
      <p>A <uicontrol>volume-group</uicontrol> is used to present disk devices in a LVM volume
        group. It also contains details of the logical volumes to be created including the file
        system type and mount point. Logical volume sizes are expressed as a percentage of the total
        capacity of the volume group. A <uicontrol>logical-volume</uicontrol> can also be consumed
        by a service in the same way as a <uicontrol>device-group</uicontrol>. This allows services
        to manage their own devices on configurations that have limited numbers of disk drives.</p>
    </section>
    <section id="servers"><title>Servers</title>
      <p><i><uicontrol>Servers</uicontrol> have a <uicontrol>server-role</uicontrol> which
          determines how they will be used in the cloud.</i></p>
      <p><uicontrol>Servers</uicontrol> (in the disk model) enumerate the resources available for
        your cloud. In addition, in this definition file you can either provide <keyword keyref="kw-hos"/>
        with all of the details it needs to PXE boot and install an operating system onto the
        server, or, if you prefer to use your own operating system installation tooling you can
        simply provide the details needed to be able to SSH into the servers and start the
        deployment.</p>
      <p>The address specified for the server will be the one used by <keyword keyref="kw-hos"/> for
        lifecycle management and must be part of a network which is in the input model. If you are
        using <keyword keyref="kw-hos"/> to install the operating system this network must be an untagged
        VLAN. The first server must be installed manually from the <keyword keyref="kw-hos"/> ISO and this
        server must be included in the input model as well.</p>
      <p>In addition to the network details used to install or connect to the server, each server
        defines what its <uicontrol>server-role</uicontrol> is and to which
          <uicontrol>server-group</uicontrol> it belongs.</p>
    </section>
    <section id="servergroups"><title>Server Groups</title>
      <p><i>A <uicontrol>server</uicontrol> is associated with a
          <uicontrol>server-group</uicontrol>.</i></p>
      <p><i>A <uicontrol>control-plane</uicontrol> can use <uicontrol>server-groups</uicontrol> as
          failure zones for server allocation.</i></p>
      <p><i>A <uicontrol>server-group</uicontrol> may be associated with a list of
            <uicontrol>networks</uicontrol>.</i></p>
      <p><i>A <uicontrol>server-group</uicontrol> can contain other
            <uicontrol>server-groups</uicontrol>.</i></p>
      <p>The practice of locating physical servers in a number of racks or enclosures in a data
        center is common. Such racks generally provide a degree of physical isolation that allows
        for separate power and/or network connectivity.</p>
      <p>In the <keyword keyref="kw-hos"/> model we support this configuration by allowing you to define a
        hierarchy of <uicontrol>server-groups</uicontrol>. Each <uicontrol>server</uicontrol> is
        associated with one <uicontrol>server-group</uicontrol>, normally at the bottom of the
        hierarchy.</p>
      <p><uicontrol>Server-groups</uicontrol> are an optional part of the input model - if you don’t
        define any then all <uicontrol>servers</uicontrol> and <uicontrol>networks</uicontrol> will
        be allocated as if they are part of the same <uicontrol>server-group</uicontrol>.</p>
    </section>
    <section id="servergroups_failurezones"><title>Server Groups and Failure Zones</title>
      <p>A <uicontrol>control-plane</uicontrol> defines a list of
          <uicontrol>server-groups</uicontrol> as the failure zones from which it wants to use
        servers. All servers in a <uicontrol>server-group</uicontrol> listed as a failure zone in
        the <uicontrol>control-plane</uicontrol> and any <uicontrol>server-groups</uicontrol> they
        contain are considered part of that failure zone for allocation purposes. The following
        example shows how three levels of <uicontrol>server-groups</uicontrol> can be used to model
        a failure zone consisting of multiple racks, each of which in turn contains a number of
          <uicontrol>servers</uicontrol>.</p>
      <p><image href="../media/inputmodel/hphelionopenstack_servergroups.png"/></p>
      <p><xref href="../media/inputmodel/hphelionopenstack_servergroups_lg.png" scope="external"
          format="html">Download a high-res version</xref></p>
      <p>When allocating <uicontrol>servers</uicontrol>, the configuration processor will traverse
        down the hierarchy of <uicontrol>server-groups</uicontrol> listed as failure zones until it
        can find an available server with the required <uicontrol>server-role</uicontrol>. If the
        allocation policy is defined to be strict, it will allocate <uicontrol>servers</uicontrol>
        equally across each of the failure zones. A <uicontrol>cluster</uicontrol> or
          <uicontrol>resource-group</uicontrol> can also independently specify the failure zones it
        wants to use if needed.</p>
    </section>
    <section id="servergroups_networks"><title>Server Groups and Networks</title>
      <p>Each L3 <uicontrol>network</uicontrol> in a cloud must be associated with all or some of
        the <uicontrol>servers</uicontrol>, typically following a physical pattern (such as having
        separate networks for each rack or set of racks). This is also represented in the
        <keyword keyref="kw-hos"/> model via <uicontrol>server-groups</uicontrol>, each group lists zero or more
        networks to which <uicontrol>servers</uicontrol> associated with
          <uicontrol>server-groups</uicontrol> at or below this point in the hierarchy are
        connected.</p>
      <p>When the configuration processor needs to resolve the specific
          <uicontrol>network</uicontrol> a <uicontrol>server</uicontrol> should be configured to
        use, it traverses up the hierarchy of <uicontrol>server-groups</uicontrol>, starting with
        the group the server is directly associated with, until it finds a server-group that lists a
        network in the required network group.</p>
      <p>The level in the <uicontrol>server-group</uicontrol> hierarchy at which a
          <uicontrol>network</uicontrol> is associated will depend on the span of connectivity it
        must provide. In the above example there might be networks in some
          <uicontrol>network-groups</uicontrol> which are per rack (i.e. Rack 1 and Rack 2 list
        different networks from the same <uicontrol>network-group</uicontrol>) and
          <uicontrol>networks</uicontrol> in a different <uicontrol>network-group</uicontrol> that
        span failure zones (the network used to provide floating IP addresses to virtual machines
        for example).</p>
    </section>
    <section id="networking"><title>Networking</title>
      <p>In addition to the mapping of <uicontrol>services</uicontrol> to specific
          <uicontrol>clusters</uicontrol> and <uicontrol>resources</uicontrol> we must also be able
        to define how the <uicontrol>services</uicontrol> connect to one or more
          <uicontrol>networks</uicontrol>.</p>
      <p>In a simple cloud there may be a single L3 network but more typically there are functional
        and physical layers of network separation that need to be expressed.</p>
      <p>Functional network separation provides different networks for different types of traffic;
        for example, it is common practice in even small clouds to separate the External APIs that
        users will use to access the cloud and the external IP addresses that users will use to
        access their virtual machines. In more complex clouds it's common to also separate out
        virtual networking between virtual machines, block storage traffic, and volume traffic onto
        their own sets of networks. In the input model, this level of separation is represented by
          <uicontrol>network-groups</uicontrol>.</p>
      <p>Physical separation is required when there are separate L3 network segments providing the
        same type of traffic; for example, where each rack uses a different subnet. This level of
        separation is represented in the input model by the <uicontrol>networks</uicontrol> within
        each <uicontrol>network-group</uicontrol>.</p>
    </section>
    <section id="networkgroups"><title>Network Groups</title>
      <p><i>Service endpoints attach to <uicontrol>networks</uicontrol> in a specific
            <uicontrol>network-group</uicontrol>.</i></p>
      <p><i><uicontrol>Network-groups</uicontrol> can define routes to other
            <uicontrol>networks</uicontrol>.</i></p>
      <p><i><uicontrol>Network-groups</uicontrol> encapsulate the configuration for
            <uicontrol>services</uicontrol> via <uicontrol>network-tags</uicontrol></i></p>
      <p>A <uicontrol>network-group</uicontrol> defines the traffic separation model and all of the
        properties that are common to the set of L3 networks that carry each type of traffic. They
        define where services are attached to the network model and the routing within that
        model.</p>
      <p>In terms of <uicontrol>service</uicontrol> connectivity, all that has to be captured in the
          <uicontrol>network-groups</uicontrol> definition is the same service-component names that
        are used when defining <uicontrol>control-planes</uicontrol>. <keyword keyref="kw-hos"/> also
        allows a default attachment to be used to specify "all service-components" that aren't
        explicitly connected to another <uicontrol>network-group</uicontrol>. So, for example, to
        isolate Swift traffic, the swift-account, swift-container, and swift-object service
        components are attached to an "Object" <uicontrol>network-group</uicontrol> and all other
        services are connected to "Management" <uicontrol>network-group</uicontrol> via the default
        relationship.</p>
      <p>The details of how each service connects, such as what port it uses, if it should be behind
        a load balancer, if and how it should be registered in Keystone, and so forth, are defined
        in the service definition files provided by <keyword keyref="kw-hos"/>.</p>
      <p>In any configuration with multiple networks, controlling the routing is a major
        consideration. In <keyword keyref="kw-hos"/>, routing is controlled at the
          <uicontrol>network-group</uicontrol> level. First, all <uicontrol>networks</uicontrol> are
        configured to provide the route to any other <uicontrol>networks</uicontrol> in the same
          <uicontrol>network-group</uicontrol>. In addition, a <uicontrol>network-group</uicontrol>
        are configured to provide the route any other <uicontrol>networks</uicontrol> in the same
          <uicontrol>network-group</uicontrol>; for example, if the internal APIs are in a dedicated
          <uicontrol>network-group</uicontrol> (a common configuration in a complex network because
        a network group with load balancers cannot be segmented) then other
          <uicontrol>network-groups</uicontrol> may need to include a route to the internal API
          <uicontrol>network-group</uicontrol> so that services can access the internal API
        endpoints. Routes may also be required to define how to access an external storage network
        or to define a general default route.</p>
      <p>As part of the <keyword keyref="kw-hos"/> deployment, networks are configured to act as the
        default route for all traffic that was received via that network (so that response packets
        always return via the network the request came from).</p>
      <p>Note that <keyword keyref="kw-hos"/> will configure the routing rules on the servers it deploys
        and will validate that the routes between services exist in the model, but ensuring that
        gateways can provide the required routes is the responsibility of your network
        configuration. The configuration processor provides information about the routes it is
        expecting to be configured.</p>
      <p>For a detailed description of how the configuration processor validates routes, refer to
          <xref keyref="networkroutevalidation">Network Route
          Validation</xref>.</p>
    </section>
    <section id="loadbalancers"><title>Load Balancers</title>
      <p><uicontrol>Load-balancers</uicontrol> provide a specific type of routing and are also
        defined in <uicontrol>network-groups</uicontrol> as a relationship between the virtual IP
        address (VIP) on a network in one <uicontrol>network group</uicontrol> and a set of service
        endpoints (which may be on <uicontrol>networks</uicontrol> in the same or a different
          <uicontrol>network-group</uicontrol>).</p>
      <p>Each <uicontrol>load-balancer</uicontrol> is defined as part of the
          <uicontrol>network-group</uicontrol> where the virtual IP will be presented - it follows
        that a <uicontrol>network-group</uicontrol> containing a
          <uicontrol>load-balancer</uicontrol> can only have one <uicontrol>network</uicontrol>
        associated to it.</p>
      <p>The <uicontrol>load-balancer</uicontrol> definition includes a list of
          <uicontrol>service-components</uicontrol> and endpoint roles it will provide A virtual IP
        for. This model allows service-specific <uicontrol>load-balancers</uicontrol> to be defined
        on different <uicontrol>network-groups</uicontrol>. A "default" value is used to express
        "all service-components" which require a virtual IP address and are not explicitly
        configured in another <uicontrol>load-balancer</uicontrol> configuration. The details of how
        the <uicontrol>load-balancer</uicontrol> should be configured for each service, such as
        which ports to use, how to check for service liveness, etc, are provided in the
        <keyword keyref="kw-hos"/> supplied service definition files.</p>
      <p>The list of endpoint roles for a <uicontrol>load-balancer</uicontrol> make it possible to
        configure separate <uicontrol>load-balancers</uicontrol> for public and internal access to
        services, and the configuration processor uses this information to both ensure the correct
        registrations in Keystone and to make sure the internal traffic is routed to the correct
        endpoint. <keyword keyref="kw-hos"/> services are configured to only connect to other services via
        internal virtual IP addresses and endpoints, allowing the name and security certificate of
        public endpoints to be controlled by the customer and set to values that may not be
        resolvable/accessible from the servers making up the cloud.</p>
      <p>Note that each <uicontrol>load-balancer</uicontrol> defined in the input model will be
        allocated a separate virtual IP address even when the load-balancers are part of the same
          <uicontrol>network-group</uicontrol>. Because of the need to be able to separate both
        public and internal access, <keyword keyref="kw-hos"/> will not allow a single
          <uicontrol>load-balancer</uicontrol> to provide both public and internal access.
          <uicontrol>Load-balancers</uicontrol> in this context are logical entities (sets of rules
        to transfer traffic from a virtual IP address to one or more endpoints). Multiple
          <uicontrol>load-balancers</uicontrol> may be implemented by the same service within the
        cloud (e.g. a HA Proxy cluster).</p>
      <p>The following diagram shows a possible configuration in which the hostname associated with
        the public URL has been configured to resolve to a firewall controlling external access to
        the cloud. Within the cloud, <keyword keyref="kw-hos"/> services are configured to use the
        internal URL to access a separate virtual IP address.</p>
      <p><image href="../media/inputmodel/hphelionopenstack_loadbalancers.png"/></p>
      <p><xref href="../media/inputmodel/hphelionopenstack_loadbalancers_lg.png" scope="external"
          format="html">Download a high-res version</xref></p>
    </section>
    <section id="networktags"><title>Network Tags</title>
      <p>Network tags are defined by some <keyword keyref="kw-hos"/>
          <uicontrol>service-components</uicontrol> and are used to convey information between the
        network model and the service, allowing the dependent aspects of the service to be
        automatically configured. For example, an option in a service configuration file that needs
        the IP address of the corresponding network device on a server where that service-component
        is installed.</p>
      <p>Network tags also convey requirements a service may have for aspects of the server network
        configuration, for example, that a bridge is required on the corresponding network device on
        a server where that service-component is installed.</p>
      <p>See <xref keyref="configobj_networktags">Network Tags</xref> for more information on
        specific tags and their usage.</p>
    </section>
    <section id="networks"><title>Networks</title>
      <p><i>A <uicontrol>network</uicontrol> is part of a
        <uicontrol>network-group</uicontrol>.</i></p>
      <p><uicontrol>Networks</uicontrol> are fairly simple definitions. Each
          <uicontrol>network</uicontrol> defines the details of its VLAN, optional address details
        (CIDR, start and end address, gateway address), and which
          <uicontrol>network-group</uicontrol> it is a member of.</p>
    </section>
    <section id="interfacemodel"><title>Interface Model</title>
      <p><i>A <uicontrol>server-role</uicontrol> identifies an
            <uicontrol>interface-model</uicontrol> that describes how its network interfaces are to
          be configured and used.</i>></p>
      <p>Networks are mapped onto specific network interfaces via an
          <uicontrol>interface-model</uicontrol>, which describes the network devices that need to
        be created (bonds, ovs-bridges, etc), their properties, and the
          <uicontrol>network-groups</uicontrol> with which they are associated.</p>
      <p>An <uicontrol>interface-model</uicontrol> acts like a template; it can define how some or
        all of the <uicontrol>network-groups</uicontrol> are to be mapped for a particular
        combination of physical NICs. However, it is the <uicontrol>service-components</uicontrol>
        on each server that determine which <uicontrol>network-groups</uicontrol> are required and
        hence which interfaces and <uicontrol>networks</uicontrol> will be configured. This means
        that <uicontrol>interface-models</uicontrol> can be shared between different
          <uicontrol>server-roles</uicontrol>. For example, an API role and a database role may
        share an interface model even though they may have different disk models and they will
        require a different subset of the <uicontrol>network-groups</uicontrol>.</p>
      <p>Within an <uicontrol>interface-model</uicontrol>, physical ports are identified by a device
        name, which in turn is resolved to a physical port via a <uicontrol>nic-mapping</uicontrol>.
        To allow different physical servers to share an <uicontrol>interface-model</uicontrol>, the
          <uicontrol>nic-mapping</uicontrol> is defined as a property of each
          <uicontrol>server</uicontrol>.</p>
    </section>
    <section id="nicmapping"><title>NIC Mapping</title>
      <p>When a <uicontrol>server</uicontrol> has more than a single physical network port, a
          <uicontrol>nic-mapping</uicontrol> is required to unambiguously identify each port.
        Standard Linux mapping of ports to interface names at the time of initial discovery (e.g.
        eth0, eth1, eth2, ...) is not uniformly consister from server to server, so a mapping of PCI
        bus address to interface name is instead.</p>
      <p>This level of abstraction will also allow network functions on SRIOV-capable network cards
        to be used for network connections and consumed by services in a future release.</p>
    </section>
    <section id="firewallconfiguration"><title>Firewall Configuration</title>
      <p>The configuration processor uses the details it has about which networks and ports
          <uicontrol>service-components</uicontrol> use to create a set of firewall rules for each
        server. The model allows additional user-defined rules on a per
          <uicontrol>network-group</uicontrol> basis.</p>
    </section>




    


    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    







    
    
    

    



    
    
    
    
    
    
    
    
    
  </conbody>
</concept>
