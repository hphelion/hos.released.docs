<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="k2kfed">
  <title><ph conkeyref="HOS-conrefs/product-title"/>Keystone to Keystone Federation</title>
  <body>
    <p conkeyref="HOS-conrefs/applies-to"/>
    <section>
      <title>What is Identity Service federation?</title>
      <p>In a typical OpenStack cloud implementation that does not use federation, users
        authenticate with each service's API using the identity service (based on OpenStack
        Keystone). However, using Keystone to Keystone (K2K) federation, the user, or requester can
        have one identity to be used across services.</p>
      <p>In HPE Helion OpenStack, the service provider is the OpenStack cloud. Using Keystone to
        Keystone federation, a number of different identity providers, such as Active Directory
        Federation Services (ADFS) or SAML2 can be used to provide identity information and
        authentication. </p>
      <p>With K2K federation, an identity service instance can be the identity provider and another
        can be the service provider. </p>
      <p>Keystone to Keystone (K2K) is supported in <keyword keyref="kw-hos-phrase-30"/>. By running
        a playbook with your configuration parameters, K2K will be enabled automatically. It's
        disabled by default.</p>
      <p>Support for Keystone to Keystone federation happens on the API level, and you must
        implement it using your own client code by calling the supported APIs. Python-keystoneclient
        has supported APIs to access the K2K APIs.</p>
      <p>The file k2kclient.py, included below, is an example, and the diagram  the end of this page
        shows how the flows a client will need to access. Expand the headline for k2kclient.py to
        see the code.</p>
      
      
    </section>
    
    <section><title outputclass="headerH">k2kclient.py</title>
      <sectiondiv outputclass="insideSection">
      <codeblock outputclass="nomaxheight prettyprint">import json
import os
import requests

import xml.dom.minidom

from keystoneclient.auth.identity import v3
from keystoneclient import session

class K2KClient(object):

    def __init__(self):
        # IdP auth URL
        self.auth_url = "http://192.168.245.9:35357/v3/"
        self.project_name = "admin"
        self.project_domain_name = "Default"
        self.username = "admin"
        self.password = "vvaQIZ1S"
        self.user_domain_name = "Default"
        self.session = requests.Session()
        self.verify = False
        # identity provider Id
        self.idp_id = "z420_idp"
        # service provider Id
        self.sp_id = "z620_sp"
        #self.sp_ecp_url = "https://16.103.149.44:8443/Shibboleth.sso/SAML2/ECP"
        #self.sp_auth_url = "https://16.103.149.44:8443/v3"

    def v3_authenticate(self):
        auth = v3.Password(auth_url=self.auth_url,
                           username=self.username,
                           password=self.password,
                           user_domain_name=self.user_domain_name,
                           project_name=self.project_name,
                           project_domain_name=self.project_domain_name)

        self.auth_session = session.Session(session=requests.session(),
                                       auth=auth, verify=self.verify)
        auth_ref = self.auth_session.auth.get_auth_ref(self.auth_session)
        self.token = self.auth_session.auth.get_token(self.auth_session)

    def _generate_token_json(self):
        return {
            "auth": {
                "identity": {
                    "methods": [
                        "token"
                    ],
                    "token": {
                        "id": self.token
                    }
                },
                "scope": {
                    "service_provider": {
                        "id": self.sp_id
                    }
                }
            }
        }

    def get_saml2_ecp_assertion(self):
        token = json.dumps(self._generate_token_json())
        url = self.auth_url + 'auth/OS-FEDERATION/saml2/ecp'
        r = self.session.post(url=url,
                              data=token,
                              verify=self.verify)
        if not r.ok:
            raise Exception("Something went wrong, %s" % r.__dict__)
        self.ecp_assertion = r.text

    def _get_sp_url(self):
        url = self.auth_url + 'OS-FEDERATION/service_providers/' + self.sp_id
        r = self.auth_session.get(
           url=url,
           verify=self.verify)
        if not r.ok:
            raise Exception("Something went wrong, %s" % r.__dict__)

        sp = json.loads(r.text)[u'service_provider']
        self.sp_ecp_url = sp[u'sp_url']
        self.sp_auth_url = sp[u'auth_url']

    def _handle_http_302_ecp_redirect(self, response, method, **kwargs):
        location = self.sp_auth_url + '/OS-FEDERATION/identity_providers/' + self.idp_id + '/protocols/saml2/auth'
        return self.auth_session.request(location, method, authenticated=False, **kwargs)

    def exchange_assertion(self):
        """Send assertion to a Keystone SP and get token."""
        self._get_sp_url()
        print("SP ECP Url:%s" % self.sp_ecp_url)
        print("SP Auth Url:%s" % self.sp_auth_url)
        #self.sp_ecp_url = 'https://16.103.149.44:8443/Shibboleth.sso/SAML2/ECP'
        r = self.auth_session.post(
            self.sp_ecp_url,
            headers={'Content-Type': 'application/vnd.paos+xml'},
            data=self.ecp_assertion,
            authenticated=False, redirect=False)
        r = self._handle_http_302_ecp_redirect(r, 'GET',
            headers={'Content-Type': 'application/vnd.paos+xml'})
        self.fed_token_id = r.headers['X-Subject-Token']
        self.fed_token = r.text

if __name__ == "__main__":
    client = K2KClient()
    client.v3_authenticate()
    client.get_saml2_ecp_assertion()
    client.exchange_assertion()
    print('Unscoped token_id: %s' % client.fed_token_id)
    print('Unscoped token body:\n%s' % client.fed_token)</codeblock></sectiondiv>
    </section>
    <section>
      <title><b>Set up a service provider (SP)</b></title>
    </section>
    <section>
      <p>To set up Keystone as a service provider, follow the instructions below.</p>
      <ol id="ol_ug3_fdb_mv">
        <li>Create a config file <codeph>k2k.yml</codeph> with the following parameters and place it
          in any directory on your lifecycle manager, for example /tmp.
          <codeblock>keystone_trusted_idp: k2k
keystone_sp_conf:
	shib_sso_idp_entity_id: &lt;protocol>://&lt;idp_host>:&lt;port>/v3/OS-FEDERATION/saml2/idp
	shib_sso_application_entity_id: http://service_provider_uri_entityId
	target_domain:
		name: domain1
		description: my domain
	target_project:
		name: project1
		description: my project
	target_group:
		name: group1
		description: my group
	role:
		name: service
	idp_metadata_file: /tmp/idp_metadata.xml
	identity_provider:
		id: my_idp_id
		description: This is the identity service provider.
	mapping:
		id: mapping1
		rules_file: /tmp/k2k_sp_mapping.json
	protocol:
		id: saml2
	attribute_map:
		-
		  name: name1
		  id: id1</codeblock>
          Below are descriptions of each of the attributes.                 <table frame="all"
            rowsep="1" colsep="1" id="tv">
            <tgroup cols="2">
              <colspec colname="c1" colnum="1" colwidth="1.0*"/>
              <colspec colname="c2" colnum="2" colwidth="1.0*"/>
              <thead>
                <row>
                  <entry> Attribute</entry>
                  <entry>Definition</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>keystone_trusted_idp</entry>
                  <entry>A flag to indicate if this configuration is used for Keystone to Keystone
                    or WebSSO. The value can be either 'k2k' or 'adfs'. </entry>
                </row>
                <row>
                  <entry outputclass="tablesubhead">
                    <b>keystone_sp_conf</b></entry>
                  <entry outputclass="tablesubhead"/>
                </row>
                <row>
                  <entry>shib_sso_idp_entity_id</entry>
                  <entry> The Identity Provider URI used as an entity Id to identity the IdP. You
                    shoud use the following value -
                    &lt;protocol>://&lt;idp_host>:&lt;port>/v3/OS-FEDERATION/saml2/idp. </entry>
                </row>
                <row>
                  <entry>shib_sso_application_entity_id</entry>
                  <entry>The Service Provider URI used as an entity Id. It can be any URI here for
                    Keystone to Keystone. </entry>
                </row>
                <row>
                  <entry outputclass="tablesubhead">target_domain</entry>
                  <entry outputclass="tablesubhead">A domain where the group will be created.
                  </entry>
                </row>
                <row>
                  <entry>name</entry>
                  <entry>Any domain name. If it does not exist, it will be created or updated.
                  </entry>
                </row>
                <row>
                  <entry>description</entry>
                  <entry>Any description. </entry>
                </row>
                <row>
                  <entry outputclass="tablesubhead">target_project</entry>
                  <entry outputclass="tablesubhead">A project scope of the group. </entry>
                </row>
                <row>
                  <entry>name</entry>
                  <entry>Any project name. If it does not exist, it will be created or updated.
                  </entry>
                </row>
                <row>
                  <entry>description</entry>
                  <entry>Any description. </entry>
                </row>
                <row>
                  <entry outputclass="tablesubhead">target_group</entry>
                  <entry outputclass="tablesubhead">A group will be created from 'target_domain'.
                  </entry>
                </row>
                <row>
                  <entry>name</entry>
                  <entry>Any group name. If it does not exist, it will be created or updated.
                  </entry>
                </row>
                <row>
                  <entry>description</entry>
                  <entry>Any description. </entry>
                </row>
                <row>
                  <entry outputclass="tablesubhead">role</entry>
                  <entry outputclass="tablesubhead">A role will be assigned on 'target_project'.
                    This role impacts the IdP user scoped token permission on the service provider
                    side. </entry>
                </row>
                <row>
                  <entry>name</entry>
                  <entry>Must be an existing role. </entry>
                </row>
                <row>
                  <entry outputclass="tablesubhead">idp_metadata_file</entry>
                  <entry outputclass="tablesubhead">A reference to the IdP metadata file that
                    validates the SAML2 assertion. </entry>
                </row>
                <row>
                  <entry outputclass="tablesubhead">identity_provider</entry>
                  <entry outputclass="tablesubhead">A supported IdP </entry>
                </row>
                <row>
                  <entry>id</entry>
                  <entry>Any Id. If it does not exist, it will be created or updated. This Id needs
                    to be shared with the client so that the right mapping will be selected.
                  </entry>
                </row>
                <row>
                  <entry>description</entry>
                  <entry>Any description. </entry>
                </row>
                <row>
                  <entry outputclass="tablesubhead">mapping</entry>
                  <entry outputclass="tablesubhead">A mapping in JSON format that mapps a federated
                    user to a corresponding group. </entry>
                </row>
                <row>
                  <entry>id</entry>
                  <entry>Any Id. If it does not exist, it will be created or updated. </entry>
                </row>
                <row>
                  <entry>rules_file</entry>
                  <entry>A reference to the file that has the mapping in JSON. </entry>
                </row>
                <row>
                  <entry outputclass="tablesubhead">protocol</entry>
                  <entry outputclass="tablesubhead">The supported federation protocol. </entry>
                </row>
                <row>
                  <entry>id</entry>
                  <entry>Security Assertion Markup Language 2.0 (saml2) is the only supported
                    protocol for K2K. </entry>
                </row>
                <row>
                  <entry outputclass="tablesubhead">attribute_map</entry>
                  <entry outputclass="tablesubhead">A shibboleth mapping defined additional
                    attributes to map the attributes from the SAML2 assertion to the K2K mapping
                    that the service provider understands. K2K does not require any additional
                    attribute mapping. </entry>
                </row>
                <row>
                  <entry>name</entry>
                  <entry>An attribute name from the SAML2 assertion. </entry>
                </row>
                <row>
                  <entry>id</entry>
                  <entry>An Id that the above name will be mapped to.</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </li>
        <li>Create a metadata file that is referenced from the above config file; for example,
            <codeph>/tmp/idp_metadata.xml</codeph>. The content of the metadata file is from the IdP
          and can be found in <codeph> /etc/keystone/idp_metadata.xml</codeph>.<ol
            id="ol_myr_zgb_mv">
            <li>Create a mapping file that is referenced from the above config file, for example
                <codeph>/tmp/k2k_sp_mapping.json.</codeph> The following is an example of the
              mapping file. <codeblock>[
  {
    "local": [
      {
        "user": {
          "name": "{0}"
        }
      },
      {
        "group": {
           "name": "group1",
           "domain":{
             "name": "domain1"
           }
        }
      }
    ],
    "remote":[{
      "type": "openstack_user"
    },
    {
      "type": "Shib-Identity-Provider",
      "any_one_of":[
         "https://idp_host:5000/v3/OS-FEDERATION/saml2/idp"
      ]
     }
    ]
   }
]           </codeblock>
              <p>More details of how the K2K mapping works can be found here - <xref
                  href="https://github.com/openstack/keystone/blob/master/doc/source/mapping_combinations.rst"
                  format="html" scope="external"
                  >https://github.com/openstack/keystone/blob/master/doc/source/mapping_combinations.rst</xref></p></li>
          </ol></li>
        <li>Go to <codeph>/home/stack/scratch/ansible/next/hos/ansible</codeph> and run the
          following to enable the service provider:
          <codeblock>ansible-playbook -i hosts/verb_hosts keystone-reconfigure.yml -e@/tmp/k2k.yml</codeblock></li>
      </ol>
      <p><b><b>Set up an identity provider (IdP)</b></b></p>
      <p>To set up Keystone as an identity provider, follow these steps:</p>
      <ol>
        <li>Create a config file <codeph>k2k.yml</codeph> with the following parameters and place it
          in any directory in your lifecycle manager, for example <codeph>/tmp</codeph>.
          <codeblock outputclass="width66">keystone_k2k_idp_conf:
    service_provider: 
          -
            id: my_sp_id
            description: This is service provider.
            sp_url: https://sp_host:5000
            auth_url: https://sp_host:5000/v3
    signer_cert: -----BEGIN CERTIFICATE-----\nMIIDmDCCAoACCQDS+ZDoUfrcIzANBgkqhkiG9w0BAQsFADCBjDELMAkGA1UEBhMC\nVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExEjAQBgNVBAcMCVN1bm55dmFsZTEMMAoG\nA1UECgwDSFBFMRQwEgYDVQQLDAtFbmdpbmVlcmluZzEQMA4GA1UEAwwHSzJLX0lk\nUDEeMBwGCSqGSIb3DQEJARYPazJrX2lkcEBocGUuY29tMCAXDTE1MTEyMDAxMjg1\nMFoYDzIxMTUxMDI3MDEyODUwWjCBjDELMAkGA1UEBhMCVVMxEzARBgNVBAgMCkNh\nbGlmb3JuaWExEjAQBgNVBAcMCVN1bm55dmFsZTEMMAoGA1UECgwDSFBFMRQwEgYD\nVQQLDAtFbmdpbmVlcmluZzEQMA4GA1UEAwwHSzJLX0lkUDEeMBwGCSqGSIb3DQEJ\nARYPazJrX2lkcEBocGUuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKC\nAQEA1gRiHiwSO6L5PrtroHi/f17DQBOpJ1KMnS9FOHSm1mES2xlB46y/GebGIZp+\nivUbLvbJHdi0axcA0OuzCLPx6t338npJzEELXNHhlSJ2KHUuLtdpltsFGMISFjD5\nkuQgBi4bEUyhQFRWkcgqL3fK5lwTB/YaMRMnLA67QDvSPOFcJFZIOhICY0cVKsHJ\nxxRbi8XfNZOLE65+yq5onxZuWH+Kbg7bOGBl45YXXjncjSN/LjruoDYv+PrHuCuF\n8B9k7F7PtGaYBnqf4z79DErxdjQZvJ3rN7W/qj04gcdaeAxoHy0+cCp+2zejerEh\n00ax1NYYnPRrEhrcU8wbM47UvQIDAQABMA0GCSqGSIb3DQEBCwUAA4IBAQDD99xf\nDw4+XRzU5ii1YuJpIsFWxbCfCqAfBtz6WaEV/UssKiEkcsasOseQvD7EUMVRhxlP\ne+7Al/vazn4xwSJzthv3NQq5g5rAMuY9Dsu5Smyok6ygY1mAAJcLGfF2VtaaSo8B\nUGj5SN8jjhOG+Yh2aNOBt6GVJlE36oFeHRVPGByq/UEGlozEWT4qAZHql8/nQlzD\nhup36JhXxtgeP/DMQOAn7HYeVJQ6+xoUWZIQhvrlvDdhWskasfOtPqI0c8/BLFoL\nCvX5vYvFSXZMyhNnMOOPyf7bTXEr+TBCVaO957FLowGv8VnW/nLVEL5tkTRWVy1A\nOpKEvhlMsl5I/tle\n-----END CERTIFICATE-----
    signer_key: -----BEGIN RSA PRIVATE KEY-----\nMIIEowIBAAKCAQEA1gRiHiwSO6L5PrtroHi/f17DQBOpJ1KMnS9FOHS
            m1mES2xlB\n46y/GebGIZp+ivUbLvbJHdi0axcA0OuzCLPx6t338npJzEELXNHhlSJ2KHUuLtdp\nltsFGMISFjD5kuQgBi4bEUyhQFRWkcgqL3fK5lwTB/YaMRMnLA67QDvSPOFcJFZI\nOhICY0cVKsHJxxRbi8XfNZOLE65+yq5onxZuWH+Kbg7bOGBl45YXXjncjSN/Ljru\noDYv+PrHuCuF8B9k7F7PtGaYBnqf4z79DErxdjQZvJ3rN7W/qj04gcdaeAxoHy0+\ncCp+2zejerEh00ax1NYYnPRrEhrcU8wbM47UvQIDAQABAoIBADOcAv07q3nuJyTV\nlXKxK5zPgU4mb5gn8/jDuXGPz9vKtP1Y7ea1dbANUqIv22wvB0sgAAfOhlN8zJmU\n/SuQGTqGJJC4pKs41ECh7EBGey/uciChmbjjQCtkQXBQhx7BHGfhHm3hiNE2hVnK\nZ0HjJW6/rWcyFcbX045wTv+CbYR4cwGktQH+uzIkf4nxEzZ+v8ubx/JDLUet6eNz\nLPKLasIhiOU4YL2poX5wJ68up3SOTDHOOPlGvp26ml5ZhfhEiqnHZyR0x6vqTWi6\nwUrBOAwz6gnifmAdPLglso61b+S6VGfTCyyjCldj6Yrj8DMbPpO/gAXY2Xgs1Rpy\nAciL1wECgYEA82IDWOwNBhqnW4DzXaYRpHjx32ttPb60NKYtk4e33v9TW8IEXH5W\n4SVxFoDxor4Mmqp3k2CEKhmf6VRrxJNFYIqXRUqO5dBjh237zLVP4UCHhW3p3+uM\nKZl0bZ605jhd0WUGvzN2s0iP+1q+6m/++8hW008RB38LCKYsh6QHqjECgYEA4Rym\nq40ylLqqdCo3sYetR6eqidT7/8rZvN7EmaXHsvW1oCVhBxWd+X/7DCYztVGOOwM8\n7eKXZPtkEV3rWzgCE7NSP8X7AbOxej9Z9qYeM282KjYCHclJD/wkCwa1btX3qGGF\ngDbVw3/DcCmTkUWtq08zdz0HGfPC9fc+UTw95E0CgYA1BwrhqfSgetgx6KOdqNw5\nMJzKZ/aSOGW8/uP5O93E+W5pFJmsqV42idjc5VVAdxX58OBCvQmuvoyH4vvkBY5d\nHXUeBMOjsMausDjnfi2cT1n3qV4GiqSsP6INbEHP00IlqFRS/lyDbXDpe/kSzToK\nE7lPKu/z6Ss3RDV5jDSbUQKBgQCDJbMAPPmb5ohJtxLNTdMo7MiRFlFd+6sQuuPk\n8809OKMA0uYNP43SfroeoN79Iq9vN/q2SI2VGlR5PbNRaHblTVJ8rvYGTs71/pSF\n+s+bfY4b120yN0NmmanR9q2bDfMD2RTy1n+BLx0IamB7gRGlvTWpoRdTCk2qCMn4\nf9U6/QKBgB8g8Q9hc2WDRjk6K+xyfNZ3pCiHmjTHvCt305DhRDjEjenj0WuXW/QW\nfHvjOW+UrZXg5K56ZKNbew8i5W4McrUoxFhk5rZRisFgetD4gxSgPCuiY7fE/QDX\nScXlxGigdJBUDKkmsdO4q0H1EGXYudTYP8x14v0U8S1N
          </codeblock>
          The following are descriptions of each of the attributes. <dl>
            <dlentry>
              <dt>keystone_k2k_idp_conf</dt>
              <dd> </dd>
            </dlentry>
            <dlentry>
              <dt>service_provider</dt>
              <dd>One or more Service Provider can be defined. If it does not exist, it will be
                created or be updated. </dd>
            </dlentry>
            <dlentry>
              <dt>id</dt>
              <dd>Any Id. If it does not exist, it will be created or be updated. This Id needs to
                be shared with the client so that he knows where the Service Provider is. </dd>
            </dlentry>
            <dlentry>
              <dt>description</dt>
              <dd>Any description. </dd>
            </dlentry>
            <dlentry>
              <dt>sp_url</dt>
              <dd>Service Provider base URL. </dd>
            </dlentry>
            <dlentry>
              <dt>auth_url</dt>
              <dd>Service Provider Auth URL. </dd>
            </dlentry>
            <dlentry>
              <dt>signer_cert</dt>
              <dd>Content of self-signed certificate that is embedded in the metadata file. The
                validity is recommended to be valid for a longer period of time, for example 3650
                days(10 years). </dd>
            </dlentry>
            <dlentry>
              <dt>signer_key</dt>
              <dd>A private key that has key size 2048.</dd>
            </dlentry>
          </dl>
        </li>
        <li> Create a private key and a self-signed certificate. The command-line tool, openssl, is
          required to generate the keys and certs. If the system does not have it, you must install
          it. <ol>
            <li>Create a private key of size
              2048<codeblock>openssl genrsa -out myidp.key 2048</codeblock>
            </li>
            <li>Generate a certificate request named myidp.csr. When prompted, choose CommonName the
              server's hostname
              <codeblock>openssl req -new -key myidp.key -out myidp.csr</codeblock>
            </li>
            <li>Generate a self-signed certificate named myidp.cer
              <codeblock>openssl x509 -req -days 3650 -in myidp.csr -signkey myidp.key -out myidp.cer</codeblock></li>
          </ol>
        </li>
        <li>Go to <codeph>/home/stack/scratch/ansible/next/hos/ansible</codeph> and run the
          following to enable the service provider in Keystone
          <codeblock>ansible-playbook -i hosts/verb_hosts keystone-reconfigure.yml -e@/tmp/k2k.yml</codeblock></li>
      </ol>
    </section>
    <section><title>Test it out</title> The attached script k2kclient.py can be used as an example
      for the end-to-end flows. To run k2kclient.py follow the instructions below. <ol>
        <li>There are few parameters must be changed in the beginning of the script. For example,
          enter your specific UR, project name, user name,
          etc.<codeblock># IdP auth URL
          self.auth_url = "http://idp_host:5000/v3/"
          self.project_name = "my_project_name"
          self.project_domain_name = "my_project_domain_name"
          self.username = "test"
          self.password = "mypass"
          self.user_domain_name = "my_domain"
          # identity provider Id that is defined in the SP config
          self.idp_id = "my_idp_id"
          # service provider Id that is defined in the IdP config
          self.sp_id = "my_sp_id"</codeblock>
        </li>
        <li>Install python-keystoneclient along with its dependencies.</li>
        <li>Run the script python <codeph>k2kclient.py</codeph> and an unscoped token will be
          returned from the service provider.</li>
      </ol> At this point, the domain or project scope of the unscoped taken can be discovered by
      sending the following
      URLs:<codeblock>curl -k -X GET -H "X-Auth-Token: &lt;unscoped token>" https://&lt;sp_public_endpoint>:5000/v3/OS-FEDERATION/domains
curl -k -X GET -H "X-Auth-Token: &lt;unscoped token>" https://&lt;sp_public_endpoint:5000/v3/OS-FEDERATION/projects</codeblock>
    </section>
    <section><title>Inside Keystone to Keystone federation</title> K2K federation places a lot of
      responsibility with the end user. The complexity is apparent from the diagram below. <ol>
        <li>The user must first authenticate to his home or local cloud, or local identity provider
          Keystone instance to obtain a scoped token. </li>
        <li>The user must discover what service providers (or remote clouds) are available to him by
          querying his local cloud. </li>
        <li>For a given remote cloud, the end user must discover which resources are available to
          him to querying the remote cloud for the projects he can scope to. </li>
        <li>In order to talk to the remote cloud, the end user must first trade, with his local
          cloud, his local scoped token for SAML2 assertion for the remote cloud. </li>
        <li>The user then presents the SAML2 assertion to the remote cloud. The remote cloud applies
          its mapping for the incoming SAML2 assertion to map the user to a local ephemeral persona
          (i.e. groups) and issues an unscoped token. </li>
        <li>The user queries the remote cloud for the list of projects he has access to. </li>
        <li>The user then re-scopes his token to a given project. </li>
        <li>The user now has access to the resources owned by the project.</li>
      </ol> As depicted below, WebSSO is accomplished via a series of HTTP redirects.<note>Horizon
        never talks directly to Keystone until the end of the sequence, after the federated unscoped
        token negotiation has completed. The browser interacts with Horizon, Keystone, and ADFS on
        their respective public endpoints.</note>
      <image href="../../media/keystone/Keystone-2-Keystone-Sequence-Generic.png"
        id="image_ldf_njb_mv"/></section>

    

    <section><title>Additional testing scenarios</title>
      <p>The following tests assume one identity provider and one service provider. </p><b>Test case
        1: Any federated user in the identity provider maps to a single designated group in the
        service provider</b>
      <ol>
        <li>On the identity provider side: <codeblock>hostname=myidp.com
username=user1</codeblock>
        </li>
        <li>On the service provider side:
          <codeblock>group=group1
group_domain_name=domain1
'group1' scopes to 'project1'</codeblock>
        </li>
        <li>Mapping used: <codeblock>testcase1_1.json</codeblock>
        </li>
        <li>Expected result: The federated user will scope to 'project1' </li>
      </ol>
      <b>Test case 2: A federated user in a specific domain in the identity provider maps to two
        different groups in the service provider</b>
      <ol>
        <li> On the identity provider side:
          <codeblock>hostname=myidp.com
username=user1
user_domain_name=Default</codeblock>
        </li>
        <li>On the service provider side:
          <codeblock>group=group1
group_domain_name=domain1
'group1' scopes to 'project1' group=group2
group_domain_name=domain2
'group2' scopes to 'project2'</codeblock>
        </li>
        <li>Mapping used: <codeblock>testcase1_2.json</codeblock>
        </li>
        <li>Expected result: The federated user will scope to both 'project1' and 'project2' </li>
      </ol>
      <b>Test case 3: A federated user with a specific project in the identity provider maps to a
        specific group in the service provider</b>
      <ol>
        <li>On the identity provider side:
          <codeblock>hostname=myidp.com
username=user4
user_project_name=test1</codeblock>
        </li>
        <li>On the service provider side:
          <codeblock>group=group4
group_domain_name=domain4
'group4' scopes to 'project4'</codeblock>
        </li>
        <li>Mapping used: <codeblock>testcase1_3.json</codeblock>
        </li>
        <li>Expected result: The federated user will scope to 'project4' </li>
      </ol>
      <b>Test case 4: A federated user with a specific role in the identity provider maps to a
        specific group in the service provider</b>
      <ol>
        <li>On the identity provider side:
          <codeblock>hostname=myidp.com, username=user5, role_name=_member_</codeblock>
        </li>
        <li>On the service provider side:
          <codeblock>group=group5, group_domain_name=domain5, 'group5' scopes to 'project5'</codeblock>
        </li>
        <li>Mapping used: <codeblock>testcase1_3.json</codeblock>
        </li>
        <li>Expected result: The federated user will scope to 'project5' </li>
      </ol>
      <b>Test case 5: Retain the previous scope for a federated user</b>
      <ol>
        <li>On the identity provider side:
          <codeblock>hostname=myidp.com, username=user1, user_domain_name=Default</codeblock>
        </li>
        <li>On the service provider side:
          <codeblock>group=group1, group_domain_name=domain1, 'group1' scopes to 'project1'</codeblock>
        </li>
        <li>Mapping used: <codeblock>testcase1_1.json</codeblock>
        </li>
        <li>Expected result: The federated user will scope to 'project1' Later, we like to scope
          federated users who has the Default domain in the identity provider to 'project2' in
          addition to 'project1' </li>
        <li>On the identity provider side:
          <codeblock>hostname=myidp.com, username=user1, user_domain_name=Default</codeblock>
        </li>
        <li>On the service provider side:
          <codeblock>group=group1
group_domain_name=domain1
'group1' scopes to 'project1' group=group2
group_domain_name=domain2
'group2' scopes to 'project2'</codeblock>
        </li>
        <li>Mapping used: <codeblock>testcase1_2.json</codeblock>
        </li>
        <li>Expected result: The federated user will scope to 'project1' and 'project2' </li>
      </ol>
      <b>Test case 6: Scope a federated user to a domain </b><ol>
        <li>On the identity provider side: <codeblock>hostname=myidp.com, username=user1</codeblock>
        </li>
        <li>On the service provider side:
          <codeblock>group=group1, group_domain_name=domain1, 'group1' scopes to 'project1'</codeblock>
        </li>
        <li>Mapping used: <codeblock>testcase1_1.json</codeblock>
        </li>
        <li>Expected result: The federated user will scope to 'project1' User CLI/Curl to assign any
          existing role to 'group1' on 'domain1' User CLI/Curl to remove 'project1' scope from
          'group1' Finally result: The federated user will scope to 'domain1' </li>
      </ol>
      <b>Test case 7: Test 5 remote attributes for mapping </b><ol>
        <li>Test all the 5 different remote attributes as the following with similar test cases as
          above.<ul><li>openstack_user </li><li>openstack_user_domain </li><li>openstack_roles </li><li>openstack_project
          </li><li>openstack_project_domain</li></ul> The attribute openstack_user does not make much sense for testing
          as it is only mapped to a specific username. The attributes openstack_user_domain,
          openstack_roles and openstack_project have already been covered by the above test cases.
        </li>
      </ol>
    </section>
    <section><title>Known issues and limitations</title> Keep the following points in mind: <ul>
        <li>When a user is disabled in the IdP, the issued federated token from the service provider
          still remains valid until the token's expiration.</li>
        <li>An already issued federated token will retain its scope until its expiration. Any
          changes in the mapping on the service provider will not impact the scope of an already
          issued federated token. For example, if an already issued federated token was mapped to
          goup1 that has scope on project1, and mapping is changed to group2 that has scope on
          project2, the prevously issued federated token still has scope on project1. </li>
        <li>Scoping the federated user to a domain is not supported by default in the playbook.
          Please follow these steps to support it. <ol>
            <li>On the IdP side, set <codeph>hostname=myidp.com</codeph> and  <codeph>username=user1
              </codeph></li>
            <li>On the service provider side, set: group=group1, group_domain_name=domain1, 'group1'
              scopes to 'project1' </li>
            <li>Mapping used: testcase1_1.json </li>
            <li>Expected result: The federated user will scope to 'project1' Use CLI/Curl to assign
              any existing role to 'group1' on 'domain1' Use CLI/Curl to remove 'project1' scope
              from 'group1' </li>
            <li>Result: The federated user will scope to 'domain1' </li>
          </ol>
        </li>
        <li>K2K and WebSSO cannot be configured by putting both sets of config attributes in the
          same config file; they will overwrite each other. So they will need to be configured one
          by one. </li>
      </ul></section>
   
  </body>
</topic>
