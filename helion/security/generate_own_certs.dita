<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="tls30">
  <title><ph conkeyref="HOS-conrefs/product-title"/>Deploying Your Own CA and Certificates</title>
  <body>
    

<section><title/>In <keyword keyref="kw-hos-phrase-30"/>, you can provide your own certificate
      authority and certificates for internal and public virtual IP addresses (VIPs). Below are
      instructions on how to add your own certificates.</section><section><title>Requirements</title> Below are terms with which you should be familiar when
      generating and installing certificates.<dl>
        <dlentry>
          <dt>Fully qualified domain name (FQDN) of the public VIP</dt>
          <dd>The registered domain name. Not mandatory. It is perfectly valid to have no FQDN and
            use IP addresses instead.</dd>
        </dlentry>
        <dlentry>
          <dt>Certificate authority(CA) certificate</dt>
          <dd>Your certificates are going to be signed by a CA, possibly your internal IT. For this
            example we will use a self-signed CA.</dd>
        </dlentry>
        <dlentry>
          <dt>Server certificate</dt>
          <dd>It is easy to confuse server certificates and CA certificates. Server certificates
            reside on the server and CA certificates reside on the client. A server certificate
            affirms that the server that sent it serves a set of IP addresses and domain names and
            set of services. CA certificate is used by the client to authenticate this claim. </dd>
        </dlentry>
        <dlentry>
          <dt>SAN (subject-alt-name)</dt>
          <dd>The set of IP addresses and domain names in a server certificate certificate request:
            A template for a server certificate. This would include SANs among other things. </dd>
        </dlentry>
        <dlentry>
          <dt>CSR (Certificate Signing Request)</dt>
          <dd>A blob of data generated from a Certificate Request and sent to a CA, which would then
            sign it, produce a server certificate, and send it back. </dd>
        </dlentry>
        <dlentry>
          <dt>External VIP</dt>
          <dd>external VIP </dd>
        </dlentry>
        <dlentry>
          <dt>Internal VIP</dt>
          <dd>internal VIP</dd>
        </dlentry>
      </dl>The major difference between an external VIP certificate and an internal VIP certificate
      is that the internal VIP has about 40 domain names in the SAN. This is because each service
      has a different domain name in <keyword keyref="kw-hos-phrase-30"/>. So it is unlikely that
      you can create an internal server certificate before running the configuration processor (CP).
      But after a configuration processor run, a certificate request would be created for each of
      your cert-names. </section><section><title>Example</title>Let's say there's no FQDN for the external VIP and that you're going
      to use the default IP address provided by <keyword keyref="kw-hos-phrase-30"/>. Let's also
      assume that for the internal VIP you will use the defaults as well. If you were to call your
      certificate authority "example-CA," the CA certificate would then be called example-CA.crt and
      the key would be called example-CA.key. If you name your external VIP certificate
      "example-public-cert" and the internal VIP certificate "example-internal-cert" note the
      results below. <note>
        <keyword keyref="kw-hos-phrase-30"/> expects a CA cert to have a .crt extension or it will
        be ignored during deployment.</note><note>All input model references in this document are
        relative to ~/helion/my_cloud on a lifecycle manager.</note>
    </section><section><title>Required Input Model changes</title> Edit the load balancer configuration in
      definition/data/network_groups.yml
      <codeblock>load-balancers:
 - provider: ip-cluster
 name: lb
 tls-components:
 - default
 components:
 - vertica
 - rabbitmq
 - mysql
 - nova-metadata
 roles:
 - internal
 - admin
 cert-file: example-internal-cert #&lt;&lt;&lt;-------- Certificate name for the internal VIP

- provider: ip-cluster
 name: extlb
 external-name: myhelion.test
 tls-components:
 - default
 roles:
 - public
 cert-file: example-public-cert #&lt;&lt;&lt;-------- Certificate name for the internal VIP</codeblock>
      Commit your changes to the local git repository and run the configuration processor
      <codeblock>cd ~/helion
git add -A
git commit -m "changed VIP certificates"
cd ~/helion/hos/ansible/
ansible-playbook -i hosts/localhost config-processor-run.yml -e encrypt="" -e rekey=""</codeblock>Check
      if the certificate requests have been generated by the configuration processor for the two
      certificate files in the input model.
      <codeblock>stack@deployerincloud-ccp-c0-m1-mgmt:~/helion/my_cloud$ ls info/cert_reqs/ 
example-internal-cert example-public-cert</codeblock>
    </section><section><title>Generate a self-signed CA</title> Next, use this CA to sign server certificates.
      This CA can be thought of as your company's IT internal CA that is self-signed and whose CA
      certificates are deployed on the company machines. This way the server certificate becomes
      legitimate.
      <codeblock>export EXAMPLE_CA_KEY_FILE='example-CA.key'
export EXAMPLE_CA_CERT_FILE='example-CA.crt'
openssl req -x509 -batch -newkey rsa:2048 -nodes -out "${EXAMPLE_CA_CERT_FILE}" \
-keyout "${EXAMPLE_CA_KEY_FILE}" \
-subj "/C=UK/O=hp/CN=Autogenerated Helion Certificate Authority" \
-days 365</codeblock>You
      can tweak the subj and days settings above to meet your needs, or to test. For instance, if
      you want to test what happens when a CA expires, you can set 'days' to a very low value.  Grab
      the CP generated request files from info/cert_reqs/
      <codeblock>stack@deployerincloud-ccp-c0-m1-mgmt:~/helion/my_cloud$ cat info/cert_reqs/example-internal-cert</codeblock>Then
      copy this file to your working directory and appended a .req extension to it. Expand the
      following headline to see the request file:  </section>
   <section id="privateMetadata"><title outputclass="headerH">Cert request file</title>
     <sectiondiv outputclass="insideSection">
        <codeblock outputclass="nomaxheight">
[req]
distinguished_name = req_distinguished_name
req_extensions = v3_req
prompt = no

[ req_distinguished_name ]
CN = "helion-vip"

[ v3_req ]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
subjectAltName = @alt_names

[ alt_names ]
DNS.1 = "deployerincloud-ccp-c0-m1-mgmt"
DNS.2 = "deployerincloud-ccp-vip-CEI-API-mgmt"
DNS.3 = "deployerincloud-ccp-vip-CND-API-mgmt"
DNS.4 = "deployerincloud-ccp-vip-DES-API-mgmt"
DNS.5 = "deployerincloud-ccp-vip-FND-MDB-mgmt"
DNS.6 = "deployerincloud-ccp-vip-FND-RMQ-mgmt"
DNS.7 = "deployerincloud-ccp-vip-FND-VDB-mgmt"
DNS.8 = "deployerincloud-ccp-vip-FRE-API-mgmt"
DNS.9 = "deployerincloud-ccp-vip-GLA-API-mgmt"
DNS.10 = "deployerincloud-ccp-vip-GLA-REG-mgmt"
DNS.11 = "deployerincloud-ccp-vip-HEA-ACF-mgmt"
DNS.12 = "deployerincloud-ccp-vip-HEA-ACW-mgmt"
DNS.13 = "deployerincloud-ccp-vip-HEA-API-mgmt"
DNS.14 = "deployerincloud-ccp-vip-HUX-SVC-mgmt"
DNS.15 = "deployerincloud-ccp-vip-HZN-WEB-mgmt"
DNS.16 = "deployerincloud-ccp-vip-KEY-API-mgmt"
DNS.17 = "deployerincloud-ccp-vip-KEYMGR-API-mgmt"
DNS.18 = "deployerincloud-ccp-vip-LOG-API-mgmt"
DNS.19 = "deployerincloud-ccp-vip-LOG-SVR-mgmt"
DNS.20 = "deployerincloud-ccp-vip-MON-API-mgmt"
DNS.21 = "deployerincloud-ccp-vip-NEU-SVR-mgmt"
DNS.22 = "deployerincloud-ccp-vip-NOV-API-mgmt"
DNS.23 = "deployerincloud-ccp-vip-NOV-MTD-mgmt"
DNS.24 = "deployerincloud-ccp-vip-OCT-API-mgmt"
DNS.25 = "deployerincloud-ccp-vip-OPS-WEB-mgmt"
DNS.26 = "deployerincloud-ccp-vip-SHP-API-mgmt"
DNS.27 = "deployerincloud-ccp-vip-SWF-PRX-mgmt"
DNS.28 = "deployerincloud-ccp-vip-admin-CEI-API-mgmt"
DNS.29 = "deployerincloud-ccp-vip-admin-CND-API-mgmt"
DNS.30 = "deployerincloud-ccp-vip-admin-DES-API-mgmt"
DNS.31 = "deployerincloud-ccp-vip-admin-FND-MDB-mgmt"
DNS.32 = "deployerincloud-ccp-vip-admin-FRE-API-mgmt"
DNS.33 = "deployerincloud-ccp-vip-admin-GLA-API-mgmt"
DNS.34 = "deployerincloud-ccp-vip-admin-HEA-ACF-mgmt"
DNS.35 = "deployerincloud-ccp-vip-admin-HEA-ACW-mgmt"
DNS.36 = "deployerincloud-ccp-vip-admin-HEA-API-mgmt"
DNS.37 = "deployerincloud-ccp-vip-admin-HUX-SVC-mgmt"
DNS.38 = "deployerincloud-ccp-vip-admin-HZN-WEB-mgmt"
DNS.39 = "deployerincloud-ccp-vip-admin-KEY-API-mgmt"
DNS.40 = "deployerincloud-ccp-vip-admin-KEYMGR-API-mgmt"
DNS.41 = "deployerincloud-ccp-vip-admin-MON-API-mgmt"
DNS.42 = "deployerincloud-ccp-vip-admin-NEU-SVR-mgmt"
DNS.43 = "deployerincloud-ccp-vip-admin-NOV-API-mgmt"
DNS.44 = "deployerincloud-ccp-vip-admin-OPS-WEB-mgmt"
DNS.45 = "deployerincloud-ccp-vip-admin-SHP-API-mgmt"
DNS.46 = "deployerincloud-ccp-vip-admin-SWF-PRX-mgmt"
DNS.47 = "192.168.245.5"
IP.1 = "192.168.245.5"

=============end of certificate request file.</codeblock>
        . </sectiondiv></section><section><title>Generate a CSR</title> Now that you have a CA and a certificate request file, it's
      time to generate a CSR.
      <codeblock>export EXAMPLE_SERVER_KEY_FILE='example-internal-cert.key'
export EXAMPLE_SERVER_CSR_FILE='example-internal-cert.csr'
export EXAMPLE_SERVER_REQ_FILE='example-interna
openssl req -newkey rsa:2048-nodes -keyout "$EXAMPLE_SERVER_KEY_FILE" -out "$EXAMPLE_SERVER_CSR_FILE" -extensions v3_req -config "$EXAMPLE_SERVER_REQ_FILE"</codeblock>Note
      that in production you would usually send the generated example-internal-cert.csr file to your
      IT department. But in this example you are your own CA, so sign and generate a server
      certificate. </section><section><title>Generate a Server Certificate</title> A server certificate is essentially a signed
      public key, the signer being a CA and trusted by a client. When we install this CA's
      certificate on the client machine, we are telling the client it's okay to trust this CA, thus
      creating a trust anchor. CA configuration file When the CA signs it uses a configuration file
      that tells it to verify the CSR.
      <!--It is in my TODO to get the gist out of this file and keep it simple but till then just use the default used
in Helion.-->
      Note that, in a production scenario the CA takes care of this for you. <!--When we finally use
      Anchor in <keyword keyref="kw-hos-phrase-30"/>, again it's not your problem, Anchor takes care
      of it. -->Create a file called openssl.cnf and add the following contents to it.
      <codeblock># Copyright 2010 United States Government as represented by the
# Administrator of the National Aeronautics and Space Administration.
# All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

#
# OpenSSL configuration file.
#

# Establish working directory.

dir = .

[ ca ]
default_ca = CA_default

[ CA_default ]
serial = $dir/serial
database = $dir/index.txt
new_certs_dir = $dir/
certificate = $dir/cacert.pem
private_key = $dir/cakey.pem
unique_subject = no
default_crl_days = 365
default_days = 365
default_md = md5
preserve = no
email_in_dn = no
nameopt = default_ca
certopt = default_ca
policy = policy_match
copy_extensions = copy

# NOTE(dprince): stateOrProvinceName must be 'supplied' or 'optional' to
# work around a stateOrProvince printable string UTF8 mismatch on
# RHEL 6 and Fedora 14 (using openssl-1.0.0-4.el6.x86_64 or
# openssl-1.0.0d-1.fc14.x86_64)
[ policy_match ]
countryName = optional
stateOrProvinceName = optional
organizationName = optional
organizationalUnitName = optional
commonName = supplied
emailAddress = optional

[ req ]
default_bits = 1024 # Size of keys
default_keyfile = key.pem # name of generated keys
default_md = md5 # message digest algorithm
string_mask = nombstr # permitted characters
distinguished_name = req_distinguished_name
req_extensions = v3_req
x509_extensions = v3_ca

[ req_distinguished_name ]
# Variable name Prompt string
#---------------------- ----------------------------------
0.organizationName = Organization Name (company)
organizationalUnitName = Organizational Unit Name (department, division)
emailAddress = Email Address
emailAddress_max = 40
localityName = Locality Name (city, district)
stateOrProvinceName = State or Province Name (full name)
countryName = Country Name (2 letter code)
countryName_min = 2
countryName_max = 2
commonName = Common Name (hostname, IP, or your name)
commonName_max = 64

# Default values for the above, for consistency and less typing.
# Variable name Value
#------------------------------ ------------------------------
0.organizationName_default = Hewlett-Packard-Enterprise
localityName_default = Bristol
stateOrProvinceName_default = Bristol
countryName_default = UK

[ v3_ca ]
basicConstraints = CA:TRUE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid:always,issuer:always
subjectAltName = @alt_names

[ v3_req ]
basicConstraints = CA:FALSE
subjectKeyIdentifier = hash

[ alt_names ]

######### end of openssl.cnf #########</codeblock>
    </section><section><title>Sign and create a server certificate</title> Now you can sign the server certificate
      with your CA.
      <codeblock>export EXAMPLE_SERVER_CERT_FILE='example-internal-cert.crt'
export EXAMPLE_SERVER_CSR_FILE='example-internal-cert.csr'
export EXAMPLE_CA_KEY_FILE='example-CA.key'
export EXAMPLE_CA_CERT_FILE='example-CA.crt'

touch index.txt
openssl rand -hex -out serial 6

openssl ca -batch -notext -md sha256 -in "$EXAMPLE_SERVER_CSR_FILE" \
-cert "$EXAMPLE_CA_CERT_FILE" \
-keyfile "$EXAMPLE_CA_KEY_FILE" \
-out "$EXAMPLE_SERVER_CERT_FILE" \
-config openssl.cnf -extensions v3_req</codeblock>
      Finally, concatenate both the server key and certificate in preparation for uploading to the
      lifecycle manager.
      <codeblock>cat example-internal-cert.key example-internal-cert.crt > example-internal-cert</codeblock>Note
      that you have only created the internal-cert in this example. Repeat the above sequence for
      example-public-cert. Make sure you use the appropriate certificate request generated by the
      configuration processor. </section><section><title>Uploading to the lifecycle manager</title> The following two files created from the
      example run above will need to be uploaded to the lifecycle manager and copied under
      config/tls. <ul>
        <li> example-internal-cert </li>
        <li> example-CA.crt</li>
      </ul> Once on the lifecycle manager, execute the followig two copy commands to copy to the
      following directories.
      <codeblock>cp example-internal-cert example-public-cert ~/helion/my_cloud/config/tls/certs/
cp example-CA.crt ~/helion/my_cloud/config/tls/cacerts/</codeblock>
      Continue with the deployment. Now you can run ready-deployment and site.yml (or
      hlm-reconfigure if you were reconfiguring the certificates) </section>
  </body>
</topic>
