<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="configuring_tls">
  <title><ph conkeyref="HOS-conrefs/product-title"/>Configuring TLS</title>
  <body>
    <p conkeyref="HOS-conrefs/applies-to"/>
    <section id="about">
      <p outputclass="aTest">The Transport Layer Security (TLS) protocol, successor to SSL, provides
        the mechanisms to ensure authentication, non-repudiation, confidentiality, and integrity of
        user communications to the <keyword keyref="kw-hos"/> services from public endpoints.</p>
      <p>OpenStack endpoints are HTTP (REST) services providing APIs to other OpenStack services on
        the management network. All traffic to OpenStack services coming in on the public endpoints
        and traffic between services are secured using TLS connections.</p>
      <p>This document has the following sections:</p>
      <ul>
        <li><xref href="tls.dita#configure_tls/notes">Notes</xref></li>
        <li><xref href="tls.dita#configure_tls/selfsigned_cert">Creating a Self-Signed
            Certificate</xref></li>
        <li><xref href="tls.dita#configure_tls/install_cert">Installing Your SSL
          Certificate</xref></li>
        <li><xref href="tls.dita#configure_tls/renewal">Installing a Renewed Certificate</xref></li>
        <li><xref href="tls.dita#configure_tls/disable">Disabling TLS</xref></li>
        <li><xref href="tls.dita#configure_tls/configure_cipher">Configuring the Cipher Suite for
            Public Endpoints</xref></li>
      </ul>
      
    </section>
    
    
    <section><title> Changes from HPE Helion OpenStack 2.x</title>
      <ul>
        <li>API endpoints in the internal and admin VIPs can now be secured by TLS. </li>
        <li>Barbican-api can be secured by TLS from the load balancer to service endpoint. </li>
        <li>Support for multiple trust chains (CA certificates) </li>
      </ul> In <keyword keyref="kw-hos-phrase"/>: <ul>
        <li>All API services are behind TLS </li>
        <li>TLS can be turned off and on after deployment. </li>
      </ul>
    </section>
    <section id="notes"><title>Background notes</title>
      <p>All of the <keyword keyref="kw-hos-phrase"/> example cloud models ship with TLS enabled on
        the service API endpoints. Because TLS is enabled by default, a test certificate is bundled
        with the release named <codeph>my-public-cert</codeph>. Having this default cert allows you
        to bring up a cloud without having to worry about certificates. It will not match the IP
        address of your environment's API endpoints, but you can ignore the warnings. Later, in
        production when you require a trusted certificate, you can add your own certificate and
        redeploy using the instructions below.</p>
      <p>You will need to choose if you want TLS on or off. We recommend keeping TLS on. But if you
        want it disabled you need to change "tls-components" to "components" in
          <codeph>network_groups.yml</codeph> and comment out the cert-file. By default, Horizon is
        configured with TLS in the input model (hlm-input-model). Note that you should not disable
        TLS in the input model for Horizon. You should keep all services behind TLS, but in the
        input model you are able to turn TLS off for a service for troubleshooting or debugging. TLS
        should always be enabled for production environments.</p>
      <p>For more details about the input model, see <xref
          href="../input_model.dita#input_model/co_networkgroups">Input Model - Network
          Groups</xref> and <xref
          href="../example_configurations.dita#example_configurations/networkgroups">Example
          Configurations - Network_groups.yml</xref></p>
    </section>
    <section id="selfsigned_cert">
      <title>Creating a self-signed certificate</title>
      <p>If you want to install a self-signed certificate for testing purposes that meets the needs
        of <keyword keyref="kw-hos"/> and then install it by following the installation in the next
        section.</p>
      <note type="important">Self-signed certificates should not be used in a production
        environment, they are meant for testing only.</note>
      <p>The domain name in the certificate signing request in step 1 below and the DNS entry in
        step 2 must match, although the domain does not have to exist.</p>
      <p>In step 2 you need the same IP address listed for both the DNS and the IP entries. Note
        that as you examine the certificate output, the issuer will match the subject because the
        cert is self-signed. The requirement for the DNS entry stems from a low-level Python
        bug.</p>
      <p>The example below shows you how to create a self-signed certificate named
          <codeph>my-public-cert</codeph>:</p>
      <ol>
        <li>Create a Certificate Signing Request (CSR) with a defined subject:
          <codeblock>openssl req -nodes -newkey rsa:2048 -keyout my-public-cert.key -out my-public-cert.csr -text \
-subj '/C=US/O=Helion Test Certificate/CN=your.domain.com/emailAddress=test@ficticious.org/'</codeblock>
        </li>
        <li>Create a file containing v3 extensions Ensure that the DNS entry matches any CN entry
          above and provide your IP
          <codeblock>cat > v3_ext.cnf &lt;&lt; *EOF*
[ v3_req ]
subjectAltName=DNS:your.domain.com,DNS:10.0.0.1, IP:10.0.0.1
*EOF*</codeblock>
        </li>
        <li>Self-sign your certificate
          <codeblock>openssl x509 â€“days 365 -extfile v3_ext.cnf -extensions v3_req -in my-public-cert.csr -signkey my-public-cert.key -req -text -out my-public-cert.crt</codeblock>
        </li>
        <li>You will need to combine the contents of the <codeph>my-public-cert.key</codeph> and
            <codeph>my-public-cert.crt</codeph> files into a single file prior to copying that file
          into your <codeph>~/helion/my_cloud/config/tls/certs/</codeph> in the steps in the next
          section.</li>
      </ol>
    </section>
    <section id="install_cert"><title>Installing your SSL certificate</title>
      <p><b>Prerequisites</b></p>
      <p>These steps assume you have already created or obtained a valid SSL certificate for your
        environment that references either the FQDN you chose or the IP address for the public API
        endpoint noted in your <codeph>~/helion/my_cloud/info/address_info.yml</codeph> file.</p>
      <p><b>Specifying your certificate in the input model</b></p>
      <p>Follow the steps below to specify the certificate in the input files:</p>
      <ol>
        <li>Log in to the lifecycle manager.</li>
        <li>Copy the certificate (containing both public and private keys) to the
            <codeph>~/helion/my_cloud/config/tls/certs/</codeph> directory.</li>
        <li id="private1">Replace the contents of
            <codeph>~/helion/hos/ansible/roles/tls-trust/files/frontend_cacert.pem</codeph> with the
          new CA certificate chain file provided by the entity that signed the certificate file that
          you added in the previous step. Since the CA certificate chain is essentially a public key
          and will be installed on all clients, take care that you don't accidently copy the
          contents of the certificate (which contains the private key) itself into the
            <codeph>frontend_cacert.pem</codeph> file.</li>
        <li>Edit <codeph>~/helion/my_cloud/definition/data/network_groups.yml</codeph> and set the
          values for <codeph>external-name</codeph> and <codeph>cert-file</codeph> to match the
          values for your environment. <p>If you are using IP addresses only then you will comment
            out the <codeph>external-name</codeph> value. Example:</p>
          <codeblock>
  - name: EXTERNAL-API
    hostname-suffix: extapi
            
    load-balancers:
       - provider: ip-cluster
         name: extlb
         # If external-name is set then public urls in keystone
         # will use this name instead of the IP address
         # You must either set this to a name that can be resolved in your network
         # or comment out this line to use IP addresses
         <b>#external-name:</b>

         tls-components:
            - default
         roles:
            - public
         <b>cert-file: &lt;cert-name></b></codeblock>
          <p>If you are using a FQDN then you will specify that in the
              <codeph>external-name</codeph> value, ensuring it matches the FQDN you used when
            creating your certificate. Example:</p>
          <codeblock>
  - name: EXTERNAL-API
    hostname-suffix: extapi
        
    load-balancers:
       - provider: ip-cluster
         name: extlb
         # If external-name is set then public urls in keystone
         # will use this name instead of the IP address
         # You must either set this to a name that can be resolved in your network
         # or comment out this line to use IP addresses
         <b>external-name: &lt;FQDN></b>
            
         tls-components:
            - default
         roles:
            - public
         <b>cert-file: &lt;cert-name></b></codeblock></li>
      </ol>
      <note>Do not enable TLS on the internal load balancer, except for the <xref
          href="../upgrade/enable_barbican_for_upgrade.dita#barbicanUpgrade/tls">Barbican Key
          Management service</xref>, which expects encrypted traffic all the way to the service
        endpoint.</note>
      <p><b>Definitions</b></p>
      <dl>
        <dlentry>
          <dt>name: extlb</dt>
          <dd>The external load balancer</dd>
        </dlentry>
        <dlentry>
          <dt>external-name:</dt>
          <dd>This name will be used in place of the external VIP address. This name can be an FQDN.
            This will be registered in the public endpoints of the services. As noted above,
              <codeph>myhelion.test</codeph> should be changed to your FQDN.</dd>
        </dlentry>
        <dlentry>
          <dt>tls-components:</dt>
          <dd>This list of services will be behind TLS. Note this is only being done for the load
            balancer in question, which is the external load balancer. The components in 'default'
            are those services defined under service-components in
              <codeph>~/helion/my_cloud/definition/data/control_plane.yml</codeph>. If you want to
            have a finer granularity, you can replace default with a list of individual components,
            such as: <codeblock>tls-components: - 'horizon' </codeblock></dd>
        </dlentry>
        <dlentry>
          <dt>cert-file:</dt>
          <dd>The default <codeph>my-public-cert</codeph> is already part of the playbook but you
            can specify your own name. When you specify your own you also need to have the
            certificate copied in <codeph>~/helion/my_cloud/config/tls/certs</codeph> on the
            lifecycle manager, as noted above.</dd>
        </dlentry>
      </dl>
      <p><b>Deploy Your Certificate</b></p>
      <ol>
        <li>Commit your changes to git:
          <codeblock>cd ~/helion/hos/ansible
git add -A
git commit -m "My config or other commit message"</codeblock></li>
        <li>Run the configuration processor:
          <codeblock>cd ~/helion/hos/ansible
ansible-playbook -i hosts/localhost config-processor-run.yml</codeblock></li>
        <li>At this point if you are doing this during the initial installation prior to your first
          run of the <codeph>site.yml</codeph> playbook then you should just continue on with the
          installation instructions. However, if you are changing or adding a new certificate
          post-installation then proceed to the next steps.</li>
        <li>Create the deployment directory:
          <codeblock>cd ~/helion/hos/ansible
ansible-playbook -i hosts/localhost ready-deployment.yml</codeblock></li>
        <li>Complete the deployment of your certificate by running the playbooks below. <p>To deploy
            the new certificate:</p>
          <codeblock>cd ~/scratch/ansible/next/hos/ansible
ansible-playbook -i hosts/verb_hosts FND-CLU-deploy.yml</codeblock>
          <p>To deploy the CA chain:</p>
          <codeblock>cd ~/scratch/ansible/next/hos/ansible
ansible-playbook -i hosts/verb_hosts horizon-deploy.yml</codeblock></li>
        <li>If you have utilized a FQDN for your public Identity endpoint, you will need to
          reconfigure the Nova service using the playbook below to ensure that the VNC proxy system
          picks up this change:
          <codeblock>cd ~/scratch/ansible/next/hos/ansible
ansible-playbook -i hosts/verb_hosts nova-reconfigure.yml</codeblock></li>
      </ol>
      <p>Note that the certificate that is installed by default, "my-public-cert", is linked to the
        name "myhelion.test". It is possible to deploy the system without generating or configuring
        a new certificate and come back and change it later, but access to the public URLS will have
        to use the "--insecure" flag to avoid "certificate mismatch" errors.</p>
    </section>

    <section id="renewal"><title>Installing a Renewed Certificate</title>
      <p>If you previously installed a certificate that has now expired and need to install your
        renewed certificate, these steps will show you how.</p>
      <ol>
        <li>Log in to the lifecycle manager.</li>
        <li>Copy the new certificate (containing both public and private keys) to the
            <codeph>~/helion/my_cloud/config/tls/certs/</codeph> directory.</li>
        <li>Replace the contents of
            <codeph>~/helion/hos/ansible/roles/tls-trust/files/frontend_cacert.pem</codeph> with the
          new CA certificate chain file provided by the entity that signed the certificate file that
          you added in the previous step. Since the CA certificate chain is essentially a public key
          and will be installed on all clients, take care that you don't accidently copy the
          contents of the certificate (which contains the private key) itself into the
            <codeph>frontend_cacert.pem</codeph> file.</li>
        <li>If your renewed certificate has the same name as your previous certificate then skip to
          the next step. However, if your renewed certificate has a new name then you will need to
          update your <codeph>~/helion/my_cloud/definition/data/network_groups.yml</codeph> file
          with the new information. See the <xref href="tls.dita#configure_tls/install_cert"
            >Installing Your SSL Certificate</xref> section above for more details.</li>
        <li>Once that is complete you can then deploy your renewed certificate: <ol>
            <li>Commit your changes to git:
              <codeblock>cd ~/helion/hos/ansible
git add -A
git commit -m "My config or other commit message"</codeblock></li>
            <li>Run the configuration processor:
              <codeblock>cd ~/helion/hos/ansible
ansible-playbook -i hosts/localhost config-processor-run.yml</codeblock></li>
            <li>Create the deployment directory:
              <codeblock>cd ~/helion/hos/ansible
ansible-playbook -i hosts/localhost ready-deployment.yml</codeblock></li>
            <li>Complete the deployment of your certificate by running the playbooks below. <p>To
                deploy the new certificate:</p>
              <codeblock>cd ~/scratch/ansible/next/hos/ansible
ansible-playbook -i hosts/verb_hosts FND-CLU-deploy.yml</codeblock>
              <p>To deploy the CA chain:</p>
              <codeblock>cd ~/scratch/ansible/next/hos/ansible
ansible-playbook -i hosts/verb_hosts horizon-deploy.yml</codeblock></li>
          </ol>
        </li>
      </ol>
    </section>

    <section id="disable"><title>Disabling TLS</title>
      <p>If you don't want to use TLS, then you should change "tls-components" to "components" in
          <codeph>network_groups.yml</codeph>. Additionally, if you have a
          <codeph>network_groups.yml</codeph> file from a previous installation, you won't have TLS
        enabled unless you change "components" to "tls-components" in that file.</p>
    </section>

    <section id="configure_cipher">
      <title>Configuring the Cipher Suite for Public Endpoints</title>
      <p>We have set the default cipher suite to be: <codeph>HIGH:!aNULL:!eNULL:!DES:!3DES</codeph>.
        This is a recommended setting from the <xref
          href="http://docs.openstack.org/security-guide/secure-communication/introduction-to-ssl-and-tls.html"
          format="html" scope="external">OpenStack documentation site</xref>. You may override this.
        To do so, open <codeph>config/haproxy/defaults.yml</codeph> and edit it. The parameters can
        be found under haproxy_globals list.</p>
      <codeblock>- "ssl-default-bind-ciphers HIGH:!aNULL:!eNULL:!DES:!3DES"
- "ssl-default-server-ciphers HIGH:!aNULL:!eNULL:!DES:!3DES"</codeblock>
      <p>Make the changes as needed. It's best to keep the two options identical.</p>
    </section>
    <section><title>Testing</title> To check if an endpoint is behind TLS, run the following command
      which probes a keystone endpoint (as an exampe) which is behind
      TLS:<codeblock>stack@deployerincloud-ccp-c0-m1-mgmt:~$ echo | openssl s_client -connect 192.168.245.5:5000 | openssl x509 -fingerprint -noout 
        depth=0 CN = helion-vip
        verify error:num=20:unable to get local issuer certificate
        verify return:1
        depth=0 CN = helion-vip
        verify error:num=27:certificate not trusted
        verify return:1
        depth=0 CN = helion-vip
        verify error:num=21:unable to verify the first certificate
        verify return:1
        DONE
        SHA1 Fingerprint=C6:46:1E:59:C6:11:BF:72:5E:DD:FC:FF:B0:66:A7:A2:CC:32:1C:B8 </codeblock>
      The next command probes a mysql endpoint that is not behind TLS
      <codeblock>stack@deployerincloud-ccp-c0-m1-mgmt:~$ echo | openssl s_client -connect 192.168.245.5:3306 | openssl x509 -fingerprint -noout 
 140448358213264:error:140770FC:SSL routines:SSL23_GET_SERVER_HELLO:unknown protocol:s23_clnt.c:795:
 unable to load certificate
 140454148159120:error:0906D06C:PEM routines:PEM_read_bio:no start line:pem_lib.c:703:Expecting: TRUSTED CERTIFICATE</codeblock>
    </section>
    <section><title>Checking if the trust chain is correctly deployed</title>
      <codeblock>stack@padawan-ccp-c0-m1-mgmt:~$ echo | openssl s_client -connect 192.168.245.9:5000 2>/dev/null | grep code 
  Verify return code: 21 (unable to verify the first certificate)
stack@padawan-ccp-c0-m1-mgmt:~$ echo | openssl s_client -connect 192.168.245.9:5000 -CAfile /usr/local/share/ca-certificates/helion_frontend_cacert.crt 2>/dev/null | grep code 
  Verify return code: 0 (ok) </codeblock>The
      first command shows error 21 which is then fixed by providing the CA certificate file. This
      verifies that the CA certificate matches the server certificate. </section>
  </body>
</topic>