<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
  PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic xml:lang="en-us" id="Ceilo_optimize">
    <title><ph conkeyref="HOS-conrefs/product-title"/>Optimizing the Ceilometer Metering
        Service</title>
    <prolog>
        <metadata>
            <othermeta name="layout" content="default"/>
            <othermeta name="product-version" content="HPE Helion Openstack"/>
            <othermeta name="product-version" content="HPE Helion Openstack 1.1"/>
            <othermeta name="product-version1" content="HPE Helion Openstack"/>
            <othermeta name="product-version2" content="HPE Helion Openstack 1.1"/>
        </metadata>
    </prolog>
    <body>
        <p conkeyref="HOS-conrefs/applies-to"/>
        <p>You can improve API and database responsiveness by configuring metering to store only the
            data you are require. This topic provides strategies for getting the most out of
            metering while not overloading your resources.</p>
        <ul>
            <li><xref type="section" href="#Ceilo_optimize/ceilometer_nova">Enable Nova Notifications</xref></li>
            <li><xref type="section" href="#Ceilo_optimize/webserverapi">Improve Reporting API Responsiveness</xref></li>
            <li>Strategies for <xref href="metering_notifications.dita">Ceilometer Metering Service Notifications</xref></li>
            <li><xref type="section" href="#Ceilo_optimize/changing_meter_list">Change the List of Meters</xref></li>
            <li><xref type="section" href="#Ceilo_optimize/update_polling_strategy">Update the Polling Strategy and Swift Considerations</xref></li>
            <li><xref type="section" href="#Ceilo_optimize/ceilometer_post_api">Enable Ceilometer Post API</xref></li>
            <li><xref type="section" href="#Ceilo_optimize/ceilomter_sample_API">Configure Paramters for Ceilometer Query-Sample API</xref></li>
            <li><xref type="section" href="#Ceilo_optimize/ceilometer_stats">Provide Parameters for the Ceilometer Statistics API</xref></li>
            <li><xref type="section" href="#Ceilo_optimize/alarm_post-meters_APIs">Enable Alarm API and Post Meters API</xref></li>
             <li><xref type="section" href="#Ceilo_optimize/failover_support">Failover Support (HA)</xref></li>
        </ul>
        
        
        
        
        <section id="ceilometer_nova">
            <title>Enable Nova Notifications</title>
            <p>You can configure Nova to send notifications by enabling the setting in the configuration file. When enabled, Nova will send information to Ceilometer related to its usage and VM status. You must restart Nova for these changes to take effect. </p>
                
               <p> The Openstack notification daemon, also known as a polling agent, monitors the
                message bus for data being provided by other OpenStack components such as Nova. The
                notification daemon loads one or more listener plugins, using the
                    <codeph>ceilometer.notification</codeph> namespace. Each plugin can listen to
                any topic, but by default it will listen to the <codeph>notifications.info</codeph>
                topic. The listeners grab messages off the defined topics and redistribute them to
                the appropriate plugins (endpoints) to be processed into Events and Samples. After
                the Nova service is restarted, you should verify that the notification daemons are
                receiving traffic.</p>
            
            <p>For a more in-depth look at how information is sent over <i>openstack.common.rpc</i>,
                refer to the <xref
                    href="http://docs.openstack.org/developer/ceilometer/measurements.html"
                    scope="external" format="html">OpenStack Ceilometer documentation</xref>.</p>
            
            <p>Nova can be configured to send following data to Ceilometer:</p>
            <table pgwide="1"> <tgroup cols="5">
                    <colspec colname="col1" colsep="1" rowsep="1" colwidth="2*"/>
                    <colspec colname="col2" colsep="1" rowsep="1" colwidth="1*"/>
                    <colspec colname="col3" colsep="1" rowsep="1" colwidth="1.26*"/>
                    <colspec colname="col4" colsep="1" rowsep="1" colwidth="1.54*"/>
                    <colspec colname="col5" colsep="1" rowsep="1" colwidth="4.19*"/>
                    <tbody>
                        <row>
                            <entry>
                                <b>Name</b>
                            </entry>
                            <entry>
                                <b>Unit</b>
                            </entry>
                            <entry>
                                <b>Type</b>
                            </entry>
                            <entry>
                                <b>Resource</b>
                            </entry>
                            <entry>
                                <b>Note</b>
                            </entry>
                        </row>
                        <row>
                            <entry>instance</entry>
                            <entry>g</entry>
                            <entry>instance</entry>
                            <entry> inst ID</entry>
                            <entry>Existence of instance</entry>
                        </row>
                        <row>
                            <entry>instance: <varname>type</varname>
                            </entry>
                            <entry>g</entry>
                            <entry>instance</entry>
                            <entry> inst ID</entry>
                            <entry>Existence of instance of <varname>type</varname> (Where
                                    <varname>type</varname> is a valid OpenStack type.) </entry>
                        </row>
                        <row>
                            <entry>memory</entry>
                            <entry>g</entry>
                            <entry>MB</entry>
                            <entry> inst ID</entry>
                            <entry>Amount of allocated RAM. Measured in MB.</entry>
                        </row>
                        <row>
                            <entry>vcpus</entry>
                            <entry>g</entry>
                            <entry>vcpu</entry>
                            <entry> inst ID</entry>
                            <entry>Number of VCPUs</entry>
                        </row>
                        <row>
                            <entry>disk.root.size</entry>
                            <entry>g</entry>
                            <entry>GB</entry>
                            <entry> inst ID</entry>
                            <entry>Size of root disk. Measured in GB.</entry>
                        </row>
                        <row>
                            <entry>disk.ephemeral.size</entry>
                            <entry>g</entry>
                            <entry>GB</entry>
                            <entry> inst ID</entry>
                            <entry>Size of ephemeral disk. Measured in GB.</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        
            <p>To enable Nova to publish notifications:</p>
            <ol>
                <li>In a text editor, open the following file:
                    <codeblock>nova.conf</codeblock></li>
            <li>Compare the example of a working configuration file with the necessary changes to
                    your configuration file. If there is anything missing in your file, add it, and
                    then save the file.
                        <codeblock>notification_driver=messaging
notification_topics=notifications
notify_on_state_change=vm_and_task_state
instance_usage_audit=True
instance_usage_audit_period=hour</codeblock><note
                        type="important">The <codeph>instance_usage_audit_period</codeph> interval
                        can be set to check the instance's status every hour, once a day, once a
                        week or once a month. Every time the audit period elapses, Nova sends a
                        notification to Ceilometer to record whether or not the instance is alive
                        and running. Metering this statistic is critical if billing depends on
                        usage.</note></li>
           <li>To restart Nova service, run:
                        <codeblock>sudo service openstack-nova-api restart
sudo service openstack-nova-cert restart
sudo service openstack-nova-consoleauth restart
sudo service openstack-nova-scheduler restart
sudo service openstack-nova-conductor restart
sudo service openstack-nova-novncproxy restart    </codeblock><note
                        type="important">Different platforms may use their own unique command to
                        restart nova-compute services. If the above command does not work, please
                        refer to the documentation for your specific platform.</note></li>
                <li>To verify successful launch of each process, list the service components:
                    <codeblock>nova service-list
                        #Sample Output:
+----+------------------+------------+----------+---------+-------+----------------------------+-----------------+
| Id | Binary           | Host       | Zone     | Status  | State | Updated_at                 | Disabled Reason |
+----+------------------+------------+----------+---------+-------+----------------------------+-----------------+
| 1  | nova-conductor   | controller | internal | enabled | up    | 2014-09-16T23:54:02.000000 | -               |
| 2  | nova-consoleauth | controller | internal | enabled | up    | 2014-09-16T23:54:04.000000 | -               |
| 3  | nova-scheduler   | controller | internal | enabled | up    | 2014-09-16T23:54:07.000000 | -               |
| 4  | nova-cert        | controller | internal | enabled | up    | 2014-09-16T23:54:00.000000 | -               |
| 5  | nova-compute     | compute1   | nova     | enabled | up    | 2014-09-16T23:54:06.000000 | -               |
+----+------------------+------------+----------+---------+-------+----------------------------+-----------------+
            </codeblock>
                </li>
            </ol>
        
        </section>
        <lines>
        </lines>
        <section id="webserverapi">
            <title>Improve Reporting API Responsiveness</title>
            <p>Reporting APIs are the main access to the metering data stored in Ceilometer. These
                APIs are accessed by Horizon to provide basic usage data and information.</p>
            <p><keyword keyref="kw-hos"/> uses Apache2 Web Server to provide the API access. This topic provides some
                strategies to help you optimize the front-end and back-end databases. </p>
            <p>To improve the responsiveness you can increase the number of threads and processes in
                the ceilometer configuration file. The Ceilometer API runs as an WSGI processes. Each process can have a certain amount
                of threads managing the filters and applications, which can comprise the processing
                pipeline. </p>
            <p><b>To configure Apache2 to use increase the number of threads</b>, use the steps in
                    <xref href="metering_reconfig.dita#reconfig_metering/apache">Configure Apache2
                    for the Ceilometer API</xref></p>
        </section>
        
        <lines/>
        <section id="changing_meter_list">
            <title>Change the List of Meters</title>
            <p>The list of meters can be easily reduced or increased by editing the pipeline.yaml
                file and restarting the central agent. </p> 

<p>Sample compute-only pipeline.yaml file with the daily poll interval:</p>
            <codeblock>---
sources:
    - name: meter_source
      interval: 86400
      meters:
          - "instance"
          - "memory"
          - "vcpus"
          - "compute.instance.create.end"
          - "compute.instance.delete.end"
          - "compute.instance.update"
          - "compute.instance.exists"
      sinks:
          - meter_sink
sinks:
    - name: meter_sink
      transformers:
      publishers:
          - notifier://</codeblock>
            <note> This change will cause all non-default meters to stop receiving
                notifications</note>
        </section>
        <lines>
        </lines>
        <section id="update_polling_strategy">
            <title>Update the Polling Strategy and Swift Considerations</title>
            <p>Polling can put an excessive amount of strain on the system due to the amount of data that the
                system may have to process. Polling also has a severe impact on queries since the database
                will have very large amount of data to scan to respond to the query. This process usually
                consumes a large amount of CPU and memory to complete the requests. Clients can also
                experience long waits for queries to come back and, in extreme cases, even timeout.</p>
               <p> There are 5 polling meters in Swift:</p>
            <ul>
                <li> storage.objects</li>
                <li>storage.objects.size</li>
                <li>storage.objects.containers</li>
                <li>storage.containers.objects</li>
                <li>storage.containers.objects.size </li>
            </ul>
            <p>Here it is an example of the pipeline.yaml with Swift polling on an hourly
                interval.</p>
            <codeblock>---
sources:
    - name: meter_source
      interval: 604800
      meters:
          - "instance"
          - "image"
          - "image.size"
          - "image.upload"
          - "image.delete"
          - "volume"
          - "volume.size"
          - "snapshot"
          - "snapshot.size"
          - "ip.floating"
          - "network.*"
          - "compute.instance.create.end"
          - "compute.instance.delete.end"
          - "compute.instance.update"
          - "compute.instance.exists"
      sinks:
          - meter_sink
    - name: swift_source
      interval: 3600
      meters:
          - "storage.objects"
          - "storage.objects.size"
          - "storage.objects.containers"
          - "storage.containers.objects"
          - "storage.containers.objects.size"
      sinks:
          - meter_sink
sinks:
    - name: meter_sink
      transformers:
      publishers:
          - notifier://</codeblock>
            <p>Every time the polling interval is due for polling at least 5 messages per
                existing object/container in Swift are collected. The following table illustrates the
                amount of data produced hourly in different scenarios:</p>
            <table>
                <tgroup cols="4">
                    <tbody>
                        <row>
                            <entry>Swift Containers</entry>
                            <entry>Swift Objects per container</entry>
                            <entry>Samples per Hour</entry>
                            <entry>Samples stored per 24 hours</entry>
                        </row>
                        <row>
                            <entry>10</entry>
                            <entry>10</entry>
                            <entry>500</entry>
                            <entry>12000</entry>
                        </row>
                        <row>
                            <entry>10</entry>
                            <entry>100</entry>
                            <entry>5000</entry>
                            <entry>120000</entry>
                        </row>
                        <row>
                            <entry>100</entry>
                            <entry>100</entry>
                            <entry>50000</entry>
                            <entry>1200000</entry>
                        </row>
                        <row>
                            <entry>100</entry>
                            <entry>1000</entry>
                            <entry>500000</entry>
                            <entry>12000000</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <p>Looking at the data we can see that even a very small Swift storage with 10 containers and 100 files will
                store 120K samples in 24 hours, bringing it to a total of 3.6 million samples.</p>
            <note>The file size of each file does not have any impact on the number of samples
                collected. In fact the smaller the number of containers or files, the smaller the sample size.
                In the scenario where there a large number of small files and containers, the sample size is also large and the performance is at its worst.</note>
        </section>
        <lines>
        </lines>
        <section id="ceilometer_post_api">
            <title>Enable Ceilometer Post API</title>
            <b>Separate pipeline.yaml for Ceilometer Post Sample API</b>
            <p>Post Sample API is disabled by default in <keyword keyref="kw-hos-phrase"/> and its
                configured with a pipeline configuration different than the agents. The api pipeline
                has no meters enabled, so it needs to be configured with meters when the Post sample
                API is enabled. Exercise caution when adding meters to the API pipeline. Ensure that
                only those meters are added to this pipeline which are already present in the
                notification agent and the central agent pipeline. Here is a sample of the API
                pipeline:</p>
            <codeblock>---
sources:
    - name: meter_source
      interval: 600
      meters:
          - "!*"
      resources:
      discovery:
      sinks:
          - meter_sink
sinks:
    - name: meter_sink
      transformers:
      publishers:
         - notifier://</codeblock>
        </section>
        <lines>
        </lines>
        <section id="ceilomter_sample_API">
            <title>Configure Paramters for Ceilometer Query-Sample API</title>
            <p>Ceilometer query-sample API uses anonymous/alias table to cache the JOIN query
                results. When the filter parameters are not sufficiently provided, the result set
                can grow large, to the point of exceeding the temp table space available on the
                mysql database instance. If this happens, an exception is thrown, halting the query
                execution. If the resource and sample tables have close to 80~100K records, the
                suggestion is to use filter conditions or in case of wanting to get all the data,
                the temp table size should be increased to avoid query interruption.</p>
            <codeblock>ceilometer sample-list --meter image.serve -q 'resource_id=a1ec2585'</codeblock>
            <codeblock>ceilometer query-samples --filter '{"and": [{"=": {"counter_name":"cpu_util"}}, {"=": {"project":"7d4af57f557547b4a28b40b054d6ffb2"}}]}'</codeblock>
        </section>
        <lines>
        </lines>
        <section id="ceilometer_stats">
            <title>Provide Parameters for the Ceilometer Statistics API</title>
            <p>Ceilometer Statistics is an open-ended query and can put a significant load on the
                database leading to unexpected results and or failures. Ceilometer Statistics API
                does a query on sample table and obtains the minimum and maximum timestamp for the
                meter that is being queried. Based on the minimum and maximum timestamp it returns a
                few statistics If a period parameter is not supplied it simply returns few
                statistics like min, max, avg and sum If a period parameter is supplied then it
                divides the range into equal periods and finds the min, max, avg and sum for each of
                the periods It is recommended that you should always provide a query parameter with
                timestamp>={$start-timestamp} and timestamp&lt;{$end-timestamp} to cover a time
                range of at the most 1 day (24 hours) irrespective of whether you provide a period
                or not. Example: With period parameter</p>
            <codeblock>ceilometer statistics -q "timestamp&gt;=2014-12-11T00:00:10;timestamp&lt;2014-12-11T23:00:00" -m "instance" -p 3600</codeblock>
            <p>Without period parameter:</p>
            <codeblock>ceilometer statistics -q "timestamp>=2014-12-11T00:00:10;timestamp&lt;2014-12-11T23:00:00" -m "instance"</codeblock>
            The recommended values for query (-q) parameter and period (-p) parameter are </section>
        <section id="query_params"><b>query parameter (-q):</b> Always provide a timestamp range
            which restricts the query to one day (24 hours). Providing a timestamp range more than a
            day or not at all providing the time stamp range as a query parameter is not recommended
            e.g. -q "timestamp>=2014-12-11T00:00:10;timestamp&lt;2014-12-11T23:00:00" If query
            parameter and timestamp is not provided, it will end up querying all the records in the
            database which is not recommended </section>
        <section><b>period parameter(-p):</b> Provide a fairly large number for period, the
            recommended value 3600 or more (1 hour or more). Providing a period of less than 3600 is
            not recommended. e.g. -p 3600 Period parameter (value in seconds) is used to divide the
            overall time range into intervals. A small period value will translate into huge number
            of queries against the database which is not recommended </section>
        <lines>
        </lines>
        <section id="alarm_post-meters_APIs">
            <title>Enable Alarm API and Post Meters API</title>
            <p>Helion Openstack deploys Ceilometer with the foloowing default conditions:</p>
            <ul>
                <li>Ceilometer Alarms are disabled</li>
                <li>Post Meters API is also disabled </li>
                <li>Custom rule hp_disabled_rule:not_implemented is added to each of those APIs in
                    ceilometer's <b>policy.json
                    </b>.<codeblock>{
"context_is_admin": "role:admin",
"context_is_project": "project_id:%(target.project_id)s",
"context_is_owner": "user_id:%(target.user_id)s",
"segregation": "rule:context_is_admin",
 
"telemetry:create_samples": "hp_disabled_rule:not_implemented",
 
"telemetry:get_alarm": "hp_disabled_rule:not_implemented",
"telemetry:change_alarm": "hp_disabled_rule:not_implemented",
"telemetry:delete_alarm": "hp_disabled_rule:not_implemented",
"telemetry:alarm_history": "hp_disabled_rule:not_implemented",
"telemetry:change_alarm_state": "hp_disabled_rule:not_implemented",
"telemetry:get_alarm_state": "hp_disabled_rule:not_implemented",
"telemetry:create_alarm": "hp_disabled_rule:not_implemented",
"telemetry:get_alarms": "hp_disabled_rule:not_implemented",
 
"default": ""
}</codeblock>
                </li>
                <li>Accessing any of the Alarm APIs or Post Meter API will result in HTTP response
                    501 Not Implemented</li>
                <li>The following Alarm APIs are disabled
                    <codeblock>POST /v2/alarms
GET /v2/alarms
GET /v2/alarms/(alarm_id)
PUT /v2/alarms/(alarm_id)
DELETE /v2/alarms/(alarm_id)
GET /v2/alarms/(alarm_id)/history
PUT /v2/alarms/(alarm_id)/state
GET /v2/alarms/(alarm_id)/state
POST /v2/query/alarms
POST /v2/query/alarms/history</codeblock>
                </li>
                <li>Post Meters API is disabled <codeblock>POST /v2/meters/(meter_name)</codeblock>
                </li>
                <li>To manually enable any of the APIs remove the corresponding rule and restart
                    Apache</li>
            </ul>
        </section>
        <lines>
        </lines>
        <section id="failover_support">
            <title>Failover Support (HA)</title>
            <p>In the Helion environment, Ceilometer supports native Active-Active HA for
                notification agent and central agent. Agent HA support includes
                workload-balancing/distribution and failover. Tooz is the coordination engine that
                is used to coordinate workload among multiple active agent instances and maintain
                the knowledge of active instance to handle failover and group membership using
                hearbeats(pings). Zookeeper is the coordination backend used but the internals of
                that is encapsulated using Tooz which exposes APIs to manage group membership and
                retrieve workload specific to each agent. The following section in conf is used to
                configure HA:</p>
            <codeblock>[coordination]
backend_url = &lt;IP address of Zookeeper host: port> (port is usually 2181 as a zookeeper default)
heartbeat = 1.0
check_watchers = 10.0</codeblock>
            <p>For the notification agent to be configured in HA mode, additional configuration is
                needed:</p>
            <codeblock>[notification]
workload_partitioning = true</codeblock>
            <p>The notification agent HA distributes workload among multiple queues that are created
                based on the number of unique source:sink combinations in the notification agent
                pipeline configuration file. If there are additional services to be metered using
                notifications, then the recommendation is to use a separate source for those events,
                especially if the expected load of data from that source is considered high. This
                should lead to better workload balancing among multiple active notification
                agents.</p>
            <p>Ceilometer-expirer is also Active-Active HA, but the key thing is to ensure that a
                single expirer process runs when multiple processes are scheduled to run at same
                time (using cron-based scheduling) on multiple controller nodes. Tooz is used to
                pick an expirer process that acquires a lock when there are multiple contenders and
                the winning process runs. There is no failover support, as expirer is not a daemon
                anyway and is scheduled to run at pre-determined intervals. The following
                configuration is needed to enable expirer HA:</p>
            <codeblock>[database]
expirer_ha = true
expirer_ha_backend_url = &lt;IP address of coordination backend url></codeblock>
        </section>
    </body>
</topic>
