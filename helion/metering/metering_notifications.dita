<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="notifications">
  <title><ph conkeyref="HOS-conrefs/product-title"/>Ceilometer Metering Service Notifications</title>
  <body><!--not tested-->
    <p conkeyref="HOS-conrefs/applies-to"/>
    <section>
      <p>Helion OpenStack is designed to reduce the amount of data that is
        stored. Helion's use of a SQL-based cluster, which is not recommended for big data,
        means you must control the data that Ceilometer collects using the configuration files for the Ceilometer Central Agent and the Ceilometer Notification Agent.</p>
      <p>Ceilometer Central Agent (polling agent) and Ceilometer Notification Agent
        (notification agent) use different pipeline.yaml files to configure meters that are
        collected. This prevents accidentally polling for meters which can be retrieved by
        the polling agent as well as the notification agent. For example, glance image and
        image.size are meters which can be retrieved both by polling and notifications.</p>
      
      <p>In both of the separate configuration files, there is a setting for
        <codeph>interval</codeph>. The interval attribute determines the frequency, in
        seconds, of how often data is collected. You can use this setting to control the
        amount of resources that are used for notifications and for polling. For example,
        you want to use more resources for notifications and less for polling. To accomplish
        this you would set the <codeph>interval</codeph> in the polling configuration file
        to a large amount of time, such as 604800 seconds, which polls only once a week.
        Then in the notifications configuration file, you can set the
        <codeph>interval</codeph> to a higher amount, such as collecting data every 30
        seconds.</p>
      
      <note type="important">Swift account data will be collected using the polling mechanism
        in an hourly interval.</note>
      
      <p>Setting this interval to manage both notifications and polling is the recommended
        procedure when using a SQL cluster back-end.</p>
      
      <p><b>Sample Ceilometer Central Agent (polling agent) file:</b></p>
      <codeblock>#File:    ~/opt/stack/service/ceilometer-common/etc/pipeline-agent-central.yaml
---
sources:
    - name: meter_source
      interval: 600
      meters:
          - "!*"
      resources:
      discovery:
      sinks:
          - meter_sink
sinks:
    - name: meter_sink
      transformers:
      publishers:
         - notifier://</codeblock>         
      
      <p><b>Sample Ceilometer Notification Agent(notification agent) file:</b></p>
      <codeblock>#File:    ~/opt/stack/service/ceilometer-common/etc/pipeline.yaml
---          
sources:
    - name: meter_source
      interval: 30
      meters:
          - "instance"
          - "image"
          - "image.size"
          - "image.upload"
          - "image.delete"
          - "volume"
          - "volume.size"
          - "snapshot"
          - "snapshot.size"
          - "ip.floating"
          - "network"
          - "network.create"
          - "network.update"
resources:
discovery:
sinks:
          - meter_sink
sinks:
    - name: meter_sink
      transformers:
      publishers:
         - notifier://</codeblock>
      
      
      
      <p>Both of the pipeline files have two major sections:
        <dl>
          <dlentry>
            <dt>Sources</dt>
            <dd>represents the data that is collected either from notifications posted
              by services or through polling. In the Sources section there is a list
              of meters. These meters define what kind of data is collected. For a
              full list refer to the Ceilometer documentation available at: <xref
                href="http://docs.openstack.org/admin-guide/telemetry-measurements.html"
                format="html" scope="external">Telemetry Measurements</xref></dd>
          </dlentry>
          <dlentry>
            <dt>Sinks</dt>
            <dd>represents how the data is modified before it is published to the internal
              queue for collection and storage. </dd>
          </dlentry>
        </dl>You will only need to change a setting in the Sources section to control the data collection interval.</p>
      
      <p>For more information, see <xref
        href="http://docs.openstack.org/admin-guide-cloud/telemetry-measurements.html"
        format="html" scope="external"
        >Telemetry Measurements</xref>
      </p>
      
      <p><b>To change the Ceilometer Central Agent (polling) interval setting:</b></p>
      <ol>
        <li>To find the polling agent configuration file, run:
          <codeblock>cd ~/opt/stack/service/ceilometer-common/etc</codeblock></li>
        <li>In a text editor, open the following file:       
          <codeblock>pipeline-agent-central.yaml</codeblock></li>
        <li>In the following section, change the value of <codeph>interval</codeph> to the
          desired amount of time:
          <codeblock>sources:
    - name: meter_source
      interval: 600
      meters:
          - "!*"
      resources:
      discovery:</codeblock>
          In the sample code above, the polling agent will collect data every 600 seconds,
          or 10 minutes.</li>
      </ol>                 
      
      <p><b>To change the Ceilometer Notification Agent (notification agent) interval
        setting:</b></p>
      <ol>
        <li>To find the notification agent configuration file, run:
          <codeblock>cd ~~/opt/stack/service/ceilometer-common/etc</codeblock></li>
        <li>In a text editor, open the following file:       
          <codeblock>pipeline.yaml</codeblock></li>
        <li>In the following section, change the value of <codeph>interval</codeph> to
          the desired amount of time:
          <codeblock>sources:
    - name: meter_source
      interval: 30
      meters:
          - "instance"
          - "image"
          - "image.size"
          - "image.upload"
          - "image.delete"
          - "volume"
          - "volume.size"
          - "snapshot"
          - "snapshot.size"
          - "ip.floating"
          - "network"
          - "network.create"
          - "network.update"</codeblock>
          In the sample code above, the notification agent will collect data every 30
          seconds.</li>
      </ol> 
      
      <note>The <codeph>pipeline.yaml</codeph> file needs to be changed
        on all controller nodes to change the white-listing and polling strategy.</note>
      
    </section>
   
    <section id="list"><title>Editing the List of Meters</title> The list of meters can be easily
      reduced or increased by editing the pipeline configuration of the respective components (which
      are notification or central/polling agent) and subsequently restarting the respectrive agent.
      If pollsters are modified then the Central Agent requires a restart and if notifications are
      added, then the Notification Agent requires a restart. Also, Collector needs to be restarted.
      Here it is an example of compute only <b>pipeline.yml </b>with the daily polling interval:
      <codeblock>---
sources:
    - name: meter_source
      interval: 86400
      meters:
          - "instance"
          - "memory"
          - "vcpus"
          - "compute.instance.create.end"
          - "compute.instance.delete.end"
          - "compute.instance.update"
          - "compute.instance.exists"
      sinks:
          - meter_sink
sinks:
    - name: meter_sink
      transformers:
      publishers:
          - notifier://</codeblock>
      If changes are made to this configuration to enable meters at container level, every time the
      polling interval is due for polling at least 5 messages per existing object/container in Swift
      are collected. The following table illustrate the amount of data will be produce hourly in
      different scenarios: Swift Containers Swift Objects per container Number of Samples/hr Samples
      Stored in a 24H Period <table>
        <tgroup cols="4">
          <tbody>
            <row>
              <entry>Swift Containers</entry>
              <entry>Swift Objects per container</entry>
              <entry>Samples per Hour</entry>
              <entry>Samples stored per 24 hours</entry>
            </row>
            <row>
              <entry>10</entry>
              <entry>10</entry>
              <entry>500</entry>
              <entry>12000</entry>
            </row>
            <row>
              <entry>10</entry>
              <entry>100</entry>
              <entry>5000</entry>
              <entry>120000</entry>
            </row>
            <row>
              <entry>100</entry>
              <entry>100</entry>
              <entry>50000</entry>
              <entry>1200000</entry>
            </row>
            <row>
              <entry>100</entry>
              <entry>1000</entry>
              <entry>500000</entry>
              <entry>12000000</entry>
            </row>
          </tbody>
        </tgroup>
      </table> This means that even a very small Swift storage with 10 containers and 100 files will
      store 120,000 samples in 24 hours, generating a grand total of 3.6 million samples! <p>Note
        that the file size of each file does not have any impact on the number of samples collected.
        As shown above, the smallest number of samples results from polling when there are a small
        number of files and a small number of containers. When  there a lot of small files and
        containers,  the number of samples is the highest. </p></section>
    
    <section><title>Updating the Polling Strategy and Swift Considerations</title>
      <p>Polling can be very taxing on the system due to the sheer volume of data that the system
        may have to process. It also has a severe impact on queries since the database will now have
        a very large amount of data to scan to respond to the query. This consumes a great amount of
        cpu and memory. This can result in long wait times for query responses, and in extreme cases
        can result in timeouts.</p> There are 3 polling meters in Swift: <ul>
        <li>storage.objects </li>
        <li>storage.objects.size </li>
        <li>storage.objects.containers</li>
      </ul> Here is an example of <b>pipeline.yml </b>in which Swift polling is set to occur hourly.
        <codeblock>---
      sources:
      - name: swift_source
      interval: 3600
      meters:
      - "storage.objects"
      - "storage.objects.size"
      - "storage.objects.containers"
      resources:
      discovery:
      sinks:
      - meter_sink
      sinks:
      - name: meter_sink
      transformers:
      publishers:
      - notifier://</codeblock><p>With
        this configuration above, we did not enable polling of container based meters and we only
        collect 3 messages for any given tenant, one for each meter listed in the configuration
        files. Since we have 3 messages only per tenant, it doesn't create a heavy load on the MySQL
        database as it would have if container-based meters were enabled. Hence, other APIs doesn't
        get hit because of this data collection configuration. </p></section>
   
   
   
  </body>
</topic>
